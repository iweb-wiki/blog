<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Pansheng`s Blog</title><meta name="description" content="攀升的学习记录"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://wangpansheng.github.io/atom.xml" title="Pansheng`s Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/u/5598490525" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/wangpansheng" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="http://www.jianshu.com/u/75f67b3d06e9" target="_blank" class="nav-list-link">JIANSHU</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/01/31/初识Koa/" class="post-title-link">初识Koa</a></h2><div class="post-info">2018年1月31日</div><div class="post-content"><p>Koa是Express原版团队开发的一个代替express的新一代node框架。<br></div><a href="/2018/01/31/初识Koa/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/01/31/手动一步一步搭建ss/" class="post-title-link">手动一步一步搭建ss</a></h2><div class="post-info">2018年1月31日</div><div class="post-content"><h1 id="动手安装ss-教程"><a href="#动手安装ss-教程" class="headerlink" title="动手安装ss,教程"></a>动手安装ss,教程</h1><h2 id="安装具体步骤"><a href="#安装具体步骤" class="headerlink" title="安装具体步骤"></a>安装具体步骤</h2><p> 我用的是Ubuntu系统，安装步骤非常简单，一步一步执行下面的命令就好</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">&lt;!-- 如果服务器没有安装git，需要执行这一步 --&gt;</span><br><span class="line">sudo apt-get install git</span><br><span class="line">sudo apt-get install python-pip</span><br><span class="line">pip install git+https://github.com/shadowsocks/shadowsocks.git@master</span><br></pre></td></tr></table></figure></div><a href="/2018/01/31/手动一步一步搭建ss/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/07/11/css变形/" class="post-title-link">css变形</a></h2><div class="post-info">2017年7月11日</div><div class="post-content"><h1>css变形</h1>

<blockquote>
<p>  我们可以借助css3实现图片元素的倾斜、缩放、移动、以及翻转效果。</p>
</blockquote>
<h2 id="1-tranfrom属性语法"><a href="#1-tranfrom属性语法" class="headerlink" title="1.  tranfrom属性语法"></a>1.  tranfrom属性语法</h2><blockquote>
<p>  tranfrom属性让元素在一个坐标系统中变形，包含一系列变形函数，可以移动、旋转和缩放元素。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transfrom: none | &lt;transfrom-function&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>默认值为:none,表示不对元素进行变形;</li>
<li>也可以指定一个或者多个变形函数，以空格分开。如：rotate、scale、trasnslate;</li>
</ul>
<h2 id="2-变形函数介绍"><a href="#2-变形函数介绍" class="headerlink" title="2.  变形函数介绍"></a>2.  变形函数介绍</h2></div><a href="/2017/07/11/css变形/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/05/14/前后端渲染的对比/" class="post-title-link">前后端渲染的对比</a></h2><div class="post-info">2017年5月14日</div><div class="post-content"><blockquote>
<p>  服务端渲染是通过后端模板引擎编译成html,css,js,然后回传给前端来进行显示；而前端渲染则是将整个生成逻辑代码全部回传前端，再由客户端生成用户界面。</p>
</blockquote>
<h2 id="为什么会有服务端渲染与客户端渲染"><a href="#为什么会有服务端渲染与客户端渲染" class="headerlink" title="为什么会有服务端渲染与客户端渲染"></a>为什么会有服务端渲染与客户端渲染</h2><p>早期，我们每一个页面都是直接由html，css，js实现的，每一个页面彼此之间相当于是独立的，当我们的网站应用足够大的时候，每当我们需要修改网站的内容时，我们需要更改很多的代码，非常麻烦。</p>
<p>那么后来，我们聪明的程序员就想到了，使用代码生成代码，就是后端的模板引擎，人们开始广泛使用模板代替手写html，大大减少的前端的工作量。通过代码生成代码，其实就是编译，基于html等基础语言，做出了更高层次的抽象封装，增加了易用性。</p>
<p>后来h5,c3的崛起，再加上客户端硬件性能的提升，我们开始通过前端模板引擎，来在客户端渲染页面。</p>
<p>对待模板，angular，vue，react的态度都不一样。</p></div><a href="/2017/05/14/前后端渲染的对比/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/04/02/ubuntu常见问题/" class="post-title-link">ubuntu常见问题处理</a></h2><div class="post-info">2017年4月2日</div><div class="post-content"><h2 id="常见问题处理"><a href="#常见问题处理" class="headerlink" title="常见问题处理"></a>常见问题处理</h2><h3 id="1-win10和ubuntu双系统时，硬盘无法加载问题"><a href="#1-win10和ubuntu双系统时，硬盘无法加载问题" class="headerlink" title="1.  win10和ubuntu双系统时，硬盘无法加载问题"></a>1.  win10和ubuntu双系统时，硬盘无法加载问题</h3><ul>
<li><p>需要依赖于ntfs-3g，如果没有需要先安装这个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ntfs-3g</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后只用ntfsfix修复，即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ntfsfix /绝对路径</span><br></pre></td></tr></table></figure>
</li>
</ul></div><a href="/2017/04/02/ubuntu常见问题/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/04/02/ubuntu常用软件部署/" class="post-title-link">ubuntu常用软件部署</a></h2><div class="post-info">2017年4月2日</div><div class="post-content"><h1 id="ubuntu中快速安装nodejs"><a href="#ubuntu中快速安装nodejs" class="headerlink" title="ubuntu中快速安装nodejs"></a>ubuntu中快速安装nodejs</h1><h2 id="1-我们可以直接通过apt-get安装nodejs"><a href="#1-我们可以直接通过apt-get安装nodejs" class="headerlink" title="1.  我们可以直接通过apt-get安装nodejs"></a>1.  我们可以直接通过<code>apt-get</code>安装nodejs</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update //需要先刷新本地索引包</span><br><span class="line">sudo apt-get install nodejs //然后安装nodejs包</span><br><span class="line">sudo apt-get install npm    //安装npm包管理器</span><br></pre></td></tr></table></figure>
<h2 id="2-安装好的node版本较低，我们可以使用n模块升级node到你需要打版本"><a href="#2-安装好的node版本较低，我们可以使用n模块升级node到你需要打版本" class="headerlink" title="2. 安装好的node版本较低，我们可以使用n模块升级node到你需要打版本"></a>2. 安装好的node版本较低，我们可以使用n模块升级node到你需要打版本</h2><h4 id="1-node有一个-n模块，专门用来管理nodejs版本的。不过目前并不支持windows系统。我们先安装下"><a href="#1-node有一个-n模块，专门用来管理nodejs版本的。不过目前并不支持windows系统。我们先安装下" class="headerlink" title="1.  node有一个 n模块，专门用来管理nodejs版本的。不过目前并不支持windows系统。我们先安装下"></a>1.  node有一个 n模块，专门用来管理nodejs版本的。不过目前并不支持windows系统。我们先安装下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g n</span><br></pre></td></tr></table></figure>
<h4 id="2-升级到制定版本，我们可以在n加上指定的版本号就可以"><a href="#2-升级到制定版本，我们可以在n加上指定的版本号就可以" class="headerlink" title="2.  升级到制定版本，我们可以在n加上指定的版本号就可以"></a>2.  升级到制定版本，我们可以在n加上指定的版本号就可以</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo n 6.10.2</span><br></pre></td></tr></table></figure></div><a href="/2017/04/02/ubuntu常用软件部署/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/03/03/centos-01/" class="post-title-link">centos-01</a></h2><div class="post-info">2017年3月3日</div><div class="post-content"><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//查看当前centos系统的版本</span><br><span class="line">cat /etc/redhat-release</span><br><span class="line">//查看系统内核版本是32位还是64位</span><br><span class="line">uname -r</span><br><span class="line">//安装cnpm</span><br><span class="line">npm install cnpm -g --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><blockquote>
<p>  在企业生产中，一般不会直接使用root来操作，可以通过命令创建用户，并且进行切换，普通用户下，前边显示的是$符号，root下显示的是#</p>
</blockquote></div><a href="/2017/03/03/centos-01/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/01/10/nodeJS构建express框架开发简单应用/" class="post-title-link">NodeJS构建express框架开发简单应用</a></h2><div class="post-info">2017年1月10日</div><div class="post-content"><blockquote>
<p>  使用node express简单构建，配合MongoDB数据库，实现简单的增删改查操作</p>
</blockquote>
<h2 id="首先我们需要构建express本地框架结构"><a href="#首先我们需要构建express本地框架结构" class="headerlink" title="首先我们需要构建express本地框架结构"></a>首先我们需要构建express本地框架结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">express demo</span><br><span class="line">//在demo文件夹中构建express结构</span><br></pre></td></tr></table></figure>
<h2 id="然后我们运行一下，"><a href="#然后我们运行一下，" class="headerlink" title="然后我们运行一下，"></a>然后我们运行一下，</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure>
<p>执行之后，我们在浏览器打开localhost:3000就可以看到初始化的页面，</p>
<h2 id="因为我们是使用-MongoDb数据库，所以需要安装mongodb的nodeJS包，"><a href="#因为我们是使用-MongoDb数据库，所以需要安装mongodb的nodeJS包，" class="headerlink" title="因为我们是使用 MongoDb数据库，所以需要安装mongodb的nodeJS包，"></a>因为我们是使用 MongoDb数据库，所以需要安装mongodb的nodeJS包，</h2><p>mongodb包的api基本上mongodb数据库的命令行操作命令差不多，所以，如果你比较清楚命令行操作命令，使用起来就会非常方便，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//安装mongodb包</span><br><span class="line">npm install mongodb --save</span><br><span class="line">//安装依赖包</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p>
<p>至此，所有的准备工作基本完成，当然，前提你已经装好mongodb数据库，而且在使用的时候，需要全程开启数据库服务器。mongodb数据库的安装，我以前有文章有介绍过，有兴趣的可以去看看。</p>
<h2 id="我们使用MVC架构来实现针对数据库的增删改查，"><a href="#我们使用MVC架构来实现针对数据库的增删改查，" class="headerlink" title="我们使用MVC架构来实现针对数据库的增删改查，"></a>我们使用MVC架构来实现针对数据库的增删改查，</h2><ul>
<li>我们创建一个文件夹 module，就是连接控制数据库的文件。</li>
<li>我们使用routes来代替controller同样的功能，来连接视图层和数据库的连接。</li>
<li>我们的整体逻辑是，我们路由中添加一个get请求，请求中调用module中的一个操作方法，然后module中的添加方法，再去调用数据库连接，然后在使用操作api操作数据库。<h2 id="在module中首先连接到数据库"><a href="#在module中首先连接到数据库" class="headerlink" title="在module中首先连接到数据库"></a>在module中首先连接到数据库</h2></li>
</ul></div><a href="/2017/01/10/nodeJS构建express框架开发简单应用/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/01/09/MongoDB简单学习/" class="post-title-link">MongoDB数据库配合NodeJS简单使用</a></h2><div class="post-info">2017年1月9日</div><div class="post-content"><h2 id="关于-MongoDB"><a href="#关于-MongoDB" class="headerlink" title="关于 MongoDB"></a>关于 MongoDB</h2><blockquote>
<p>  我们一般把数据库分为关系型数据库和非关系型数据库，MongoDB就是属于非关系型数据库的一种。</p>
</blockquote>
<ul>
<li>官网：<a href="https://www.mongodb.com/" target="_blank" rel="noopener">https://www.mongodb.com/</a></li>
<li>下载地址：<a href="https://www.mongodb.com/download-center?jmp=nav" target="_blank" rel="noopener">https://www.mongodb.com/download-center?jmp=nav</a></li>
</ul>
<h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><ul>
<li><a href="https://www.smartftp.com/support/kb/the-program-cant-start-because-api-ms-win-crt-runtime-l1-1-0dll-is-missing-f2702.html?lang=zh-CN" target="_blank" rel="noopener">https://www.smartftp.com/support/kb/the-program-cant-start-because-api-ms-win-crt-runtime-l1-1-0dll-is-missing-f2702.html?lang=zh-CN</a></li>
<li><a href="http://stackoverflow.com/questions/33265663/api-ms-win-crt-runtime-l1-1-0-dll-is-missing-when-opening-microsoft-office-file" target="_blank" rel="noopener">http://stackoverflow.com/questions/33265663/api-ms-win-crt-runtime-l1-1-0-dll-is-missing-when-opening-microsoft-office-file</a></li>
</ul>
<h2 id="启动和关闭-MongoDB-数据库服务程序"><a href="#启动和关闭-MongoDB-数据库服务程序" class="headerlink" title="启动和关闭 MongoDB 数据库服务程序"></a>启动和关闭 MongoDB 数据库服务程序</h2><p>mongod.exe 是我们要启动的服务器文件<br>mongo的客户端去连我们的服务器</p>
<ul>
<li><p>打开终端，输入 <code>mongod</code> 回车</p>
<ul>
<li><code>mongod</code> 命令用来启动 MongoDB 数据服务</li>
<li>MongoDB 服务默认将 C:/data/db 目录作为数据目录</li>
<li>所以你需要先在 C:/ 根目录新建一个目录：C:/data/db</li>
<li>当你执行 mongod 命令的时候，默认会去使用 c:/data/db 目录作为数据存储目录</li>
<li>如果你不想使用 c:/data/db 目录</li>
<li>mongod –dbpath=路径</li>
</ul>
</li>
<li><p>32位操作系统启动 MongoDB</p>
<ul>
<li><a href="http://jingyan.baidu.com/article/76a7e409e1bb49fc3b6e1516.html" target="_blank" rel="noopener">http://jingyan.baidu.com/article/76a7e409e1bb49fc3b6e1516.html</a></li>
<li><code>mongod --dbpath 数据存储路径 --journal --storageEngine=mmapv1</code><br>mongod –dbpath C:/data/db –journal –storageEngine=mmapv1`</li>
</ul>
</li>
</ul></div><a href="/2017/01/09/MongoDB简单学习/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/11/26/数组方法梳理/" class="post-title-link">数组方法梳理</a></h2><div class="post-info">2016年11月26日</div><div class="post-content"><p><img src="/images/bg2.jpg" alt="images/bg2.jpg"></p>
<blockquote>
<p>  由于发现对数组和字符串原生的方法有点记不太清了，所以打算梳理一下，把这写方法整理一下，加强自己的记忆。</p>
<p>  以下数组演示都以数组 数组arr=[1,2,3]为原始值；</p>
</blockquote>
<h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><ul>
<li><p>返回数组的长度</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.length;<span class="comment">//返回值是3</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><ul>
<li><p>连接两个或更多数组，并返回新数组，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.concat([<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//返回是数组[1,2,3,8,9,0]</span></span><br><span class="line"><span class="comment">//不会修改原数组</span></span><br></pre></td></tr></table></figure>
</li>
</ul></div><a href="/2016/11/26/数组方法梳理/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/11/20/原生框架封装之插件开发/" class="post-title-link">原生框架封装之插件开发</a></h2><div class="post-info">2016年11月20日</div><div class="post-content"><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ol>
<li><p>历史背景</p>
<ul>
<li>http https: 都是一种无状态、无连接的协议</li>
<li>tcp/ip 是一种长连接协议</li>
<li>无论什么用户都可以访问网址页面，在实际开发中，有些页面需要先验证身份才可以访问的，此时就需要http记录用户的状态，（登录状态），</li>
<li>但是http协议是无状态的，因此就诞生了session和cookie</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li>登录功能：记录登录状态，以及一些用户基本信息。</li>
<li>用户基本信息：昵称、头像地址、加密后的密码（记住密码）、用户名</li>
</ul>
</li>
<li><p>做cookie插件的目的</p>
</li>
</ol>
<ul>
<li>方便前端人员操作cookie</li>
</ul></div><a href="/2016/11/20/原生框架封装之插件开发/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/11/18/框架封装练习3/" class="post-title-link">jqeury框架封装练习3</a></h2><div class="post-info">2016年11月18日</div><div class="post-content"><h2 id="DOM操作模块"><a href="#DOM操作模块" class="headerlink" title="DOM操作模块"></a>DOM操作模块</h2><h3 id="appendTO方法"><a href="#appendTO方法" class="headerlink" title="appendTO方法"></a>appendTO方法</h3><ol>
<li><p>语法：实例对象.appendTo(target);</p>
</li>
<li><p>功能：将调用者上的所有DOM元素，分别追加到目标元素上</p>
</li>
<li><p>target参数类型：</p>
<ul>
<li>选择器</li>
<li>DOM元素</li>
<li>DOM数组，伪数组</li>
</ul>
</li>
</ol>
<ul>
<li><p>为了更方便处理不同的类型，在实现时，首先统一target的参数类型，方便发i吗逻辑的处理</p>
</li>
<li><p>将target统一成itcast的对象，参数一致，便于处理，同时由于是itcast对象，就可以直接调用each方法进行遍历元素</p>
</li>
</ul>
<ol>
<li>实现思路</li>
</ol>
<ul>
<li>统一target类型，</li>
<li>遍历target，再遍历调用者</li>
<li>判断，当目标元素是不是第一个元素，如果是，不需要拷贝源节点，否则就要深拷贝源节点，</li>
<li>将上述得到的新节点，缓存起来到数组中，</li>
<li>再将新节点追加到dom元素中</li>
<li>将缓存的数组转换成itcast对象，作为appendTo的返回值，来实现链式编程。</li>
</ul></div><a href="/2016/11/18/框架封装练习3/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/11/17/框架封装之Ajax/" class="post-title-link">框架封装之Ajax</a></h2><div class="post-info">2016年11月17日</div><div class="post-content"><h2 id="ajax请求步骤"><a href="#ajax请求步骤" class="headerlink" title="ajax请求步骤"></a>ajax请求步骤</h2><ol>
<li>创建请求对象</li>
<li>格式化数据</li>
<li>与服务器建立连接</li>
<li>监听请求状态</li>
<li>发送请求</li>
</ol>
<h2 id="创建请求对象"><a href="#创建请求对象" class="headerlink" title="创建请求对象"></a>创建请求对象</h2><ol>
<li>原生方法<ul>
<li>w3c:XMLHttpRequest</li>
<li>IE：ActiveXObject</li>
</ul>
</li>
</ol>
<h2 id="封装Ajax模块"><a href="#封装Ajax模块" class="headerlink" title="封装Ajax模块"></a>封装Ajax模块</h2><ol>
<li><p>确定Ajax配置的默认值</p>
<ul>
<li>url =&gt; “”</li>
<li>type =&gt; “get”</li>
<li>data =&gt; {}</li>
<li>success =&gt; null</li>
<li>fail =&gt; null</li>
<li>async =&gt; true</li>
<li>dataType =&gt; “json”</li>
<li>contentType =&gt; “application/x-www-form-ulencoded”</li>
</ul>
</li>
<li><p>ajax默认配置放在哪？</p>
<ul>
<li>要用一个对象来存储上述Ajax配置信息，像jQuery一样，将其放到工厂函数上；<br>放在工厂函数jq上</li>
</ul>
</li>
</ol></div><a href="/2016/11/17/框架封装之Ajax/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/11/17/原生框架封装练习2/" class="post-title-link">原生框架封装练习02</a></h2><div class="post-info">2016年11月17日</div><div class="post-content"><h2 id="工具类方法与功能类方法"><a href="#工具类方法与功能类方法" class="headerlink" title="工具类方法与功能类方法"></a>工具类方法与功能类方法</h2><ol>
<li><p>工具类方法：</p>
<ul>
<li>可以在内部使用，也可以给使用者使用，不需要常见实例就可以调用的</li>
</ul>
</li>
<li><p>功能类方法：</p>
<ul>
<li>框架内部的对象的方法，必须使用该对象去调用，操作dom元素的方法</li>
</ul>
</li>
</ol>
<h2 id="类型判断方法"><a href="#类型判断方法" class="headerlink" title="类型判断方法"></a>类型判断方法</h2><ol>
<li><p>isString方法：判断指定 参数是不是字符串类型，</p>
</li>
<li><p>isHTML：判断指定参数是不是html字符串</p>
<ul>
<li>以&lt;开头，以&gt;结尾，长度不小于3的字符串</li>
</ul>
</li>
<li><p>isDOM：判断指定的参数是不是dom对象</p>
<ul>
<li>如果参数不为null或undefined，并且具有nodetype属性，那么类型就是dom对象</li>
</ul>
</li>
<li><p>isArrayLink：判断指定参数是不是数组或伪数组</p>
<ul>
<li>如果对象的length属性是number类型</li>
</ul>
</li>
</ol></div><a href="/2016/11/17/原生框架封装练习2/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/11/15/原生框架封装练习01/" class="post-title-link">jquery框架封装练习01</a></h2><div class="post-info">2016年11月15日</div><div class="post-content"><ul>
<li><p>我们通过原生的js实现一些jq的功能，通过练习，锻炼我们的分析问题的能力。锻炼编程的思维能力。</p>
</li>
<li><p>查询DOM方法</p>
</li>
<li>操作DOM方法<ul>
<li>appendTo</li>
<li>append</li>
<li>prependTo</li>
<li>prepend</li>
<li>next/prev</li>
<li>nextAll/prevAll</li>
<li>before</li>
<li>after</li>
<li>parent /parents</li>
<li>nextSibling</li>
<li>attr</li>
<li>prop</li>
<li>val</li>
<li>html</li>
<li>text</li>
<li>css</li>
<li>addClass</li>
<li>hasClass</li>
<li>removeClass</li>
<li>toggleClass</li>
<li>on</li>
<li>off</li>
<li>click /dbclick/keydown</li>
<li>$.ajax</li>
</ul>
</li>
</ul>
<h2 id="jQuery框架结构"><a href="#jQuery框架结构" class="headerlink" title="jQuery框架结构"></a>jQuery框架结构</h2><ol>
<li>为了防止对变量和全局对象的污染，使用沙箱模式</li>
<li>jq的功能是查询DOM和操作DOM，<ul>
<li>在查询时，通过选择器来查询。因此要使用函数去实现Dom元素的查询。在实现时，要先定义一个函数init，</li>
<li>查询到DOM后，要对这些DOM进行操作，此时，要使用面向对象编程的方式来实现，创建一个对象，然后通过该对象的方法来实现操作查询到的DOM元素。</li>
</ul>
</li>
<li>由于框架的结构在完成之后，不允许任何使用者随意改动，所以用户如果想要扩展方法，就必须向其能拿到的对象上扩展，$-&gt;createinit，也就是工厂函数以及其原型。最终要实现init对象继承自createinit函数的原型。</li>
</ol></div><a href="/2016/11/15/原生框架封装练习01/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="https://wangpansheng.github.io">Pansheng</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-113348763-1",'auto');ga('send','pageview');</script></body></html>