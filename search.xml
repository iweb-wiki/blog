<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>ubuntu安装rime输入法</title>
      <link href="/2018/04/13/ubuntu%E5%AE%89%E8%A3%85rime%E8%BE%93%E5%85%A5%E6%B3%95/"/>
      <url>/2018/04/13/ubuntu%E5%AE%89%E8%A3%85rime%E8%BE%93%E5%85%A5%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="ubuntu系统安装-rime输入法"><a href="#ubuntu系统安装-rime输入法" class="headerlink" title="ubuntu系统安装 rime输入法"></a>ubuntu系统安装 rime输入法</h2><blockquote><p>RIME／中州韻輸入法引擎，是一個跨平臺的輸入法算法框架。基於這一框架，Rime 開發者與其他開源社區的參與者在 Windows、macOS、Linux、Android 等平臺上創造了不同的輸入法前端實現</p></blockquote><p>以上是<a href="http://http://rime.im/" target="_blank" rel="noopener">RIME官网</a>的介绍，是一款开源的跨平台输入法。这里是linux平台的，Windows平台下的是小狼毫，都很好用。</p><p>因为系统自带的输入法，不是很好用，而且以前一直用的rime输入法，确实很好用，但是，由于之前没怎么用ubuntu，今天安装，遇到了一些问题，这里记录下</p><ol><li>首先 安装 ibus-rime,执行下面命令 </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ibus-rime</span><br></pre></td></tr></table></figure><ol start="2"><li>然后 安装输入方案，选择自己需要的安装</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 朙月拼音（預裝）</span><br><span class="line">sudo apt-get install librime-data-luna-pinyin</span><br><span class="line"># 雙拼</span><br><span class="line">sudo apt-get install librime-data-double-pinyin</span><br><span class="line"># 宮保拼音</span><br><span class="line">sudo apt-get install librime-data-combo-pinyin</span><br><span class="line"># 注音、地球拼音</span><br><span class="line">sudo apt-get install librime-data-terra-pinyin librime-data-bopomofo</span><br><span class="line"># 倉頡五代（預裝）</span><br><span class="line">sudo apt-get install librime-data-cangjie5</span><br><span class="line"># 速成五代</span><br><span class="line">sudo apt-get install librime-data-quick5</span><br><span class="line"># 五筆86、袖珍簡化字拼音、五筆畫</span><br><span class="line">sudo apt-get install librime-data-wubi librime-data-pinyin-simp librime-data-stroke-simp</span><br><span class="line"># IPA (X-SAMPA)</span><br><span class="line">sudo apt-get install librime-data-ipa-xsampa</span><br><span class="line"># 上海吳語</span><br><span class="line">sudo apt-get install librime-data-wugniu</span><br><span class="line"># 粵拼</span><br><span class="line">sudo apt-get install librime-data-jyutping</span><br><span class="line"># 中古漢語拼音</span><br><span class="line">sudo apt-get install librime-data-zyenpheng</span><br></pre></td></tr></table></figure><ol start="3"><li><p>但是安装之后，直接切换输入法的时候，是找不到rime，是需要先去<code>系统设置-&gt;语言支持-&gt;键盘输入法系统</code>，把默认值<code>fcitx</code>设置为<code>IBus</code>，然后再设置，如果不行就重启系统试试</p></li><li><p>rime的设置文件放在<code>~/.config/ibus/rime</code>下的<code>default.yaml</code>，执行<code>vi default.yaml</code>，编辑文件，把需要用的方案写在<code>schema_list</code>中，然后重新部署，再按ctrl+`或者F4，就可以切换方案了，</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">schema_list:</span><br><span class="line">  - schema: wubi_pinyin</span><br><span class="line">  - schema: wubi86</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> ubuntu </tag>
            
            <tag> rime </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>快速上手快应用</title>
      <link href="/2018/03/23/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E5%BF%AB%E5%BA%94%E7%94%A8/"/>
      <url>/2018/03/23/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E5%BF%AB%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<blockquote><p>快应用是国内各大厂商联合制定的，基于手机硬件平台的新型应用形态，和小程序类似，无需安装，随用随走。</p></blockquote><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><blockquote><p>首先需要安装nodejs版本6.0以上，不过官方建议不要使用8.0.*版本，会有报错.</p></blockquote><h3 id="安装hap-toolkit"><a href="#安装hap-toolkit" class="headerlink" title="安装hap-toolkit"></a>安装hap-toolkit</h3><ul><li>通过npm安装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g hap-toolkit</span><br></pre></td></tr></table></figure><ul><li>输入以下命令，检测安装是否成功<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hap -V</span><br></pre></td></tr></table></figure></li></ul><h2 id="创建第一个项目"><a href="#创建第一个项目" class="headerlink" title="创建第一个项目"></a>创建第一个项目</h2><ul><li><p>环境搭建好之后，直接输入下面命令，可以初始化我们的第一个快应用</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hap init &lt;projectName&gt;</span><br></pre></td></tr></table></figure></li><li><p>目录的简要说明如下：</p><p>  src：项目源文件夹<br>  node_modules：项目的依赖类库<br>  sign：签名模块，当前仅有debug签名，如果内测上线，请添加release文件夹，增加线上签名；签名生成方法请参考文档：编译工具的openssl</p></li></ul><h2 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h2><h3 id="安装依赖-在项目根目录输入命令安装依赖，可以使用npm或者yarn"><a href="#安装依赖-在项目根目录输入命令安装依赖，可以使用npm或者yarn" class="headerlink" title="安装依赖,在项目根目录输入命令安装依赖，可以使用npm或者yarn"></a>安装依赖,在项目根目录输入命令安装依赖，可以使用<code>npm</code>或者<code>yarn</code></h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i </span><br><span class="line">或者</span><br><span class="line">yarn</span><br></pre></td></tr></table></figure></code></pre><h3 id="编译项目，在项目根目录，进行编译打包，生成rpk包"><a href="#编译项目，在项目根目录，进行编译打包，生成rpk包" class="headerlink" title="编译项目，在项目根目录，进行编译打包，生成rpk包"></a>编译项目，在项目根目录，进行编译打包，生成rpk包</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure></code></pre><p>编译打包之后，项目根目录下会生成文件夹 <code>build</code>,<code>dist</code></p><ul><li><code>build</code>: 临时产出，包含编译后的页面js，图片等</li><li><code>dist</code>: 最终产出，包含rpk文件。其实是将build目录下的资源打包压缩为一个文件，后缀名为rpk，这个rpk文件就是项目编译后的最终产出</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>科学上网</title>
      <link href="/2017/10/31/%E6%89%8B%E6%91%B8%E6%89%8B%E6%90%AD%E5%BB%BA%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E5%8E%BB%E6%9C%8D%E5%8A%A1/"/>
      <url>/2017/10/31/%E6%89%8B%E6%91%B8%E6%89%8B%E6%90%AD%E5%BB%BA%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E5%8E%BB%E6%9C%8D%E5%8A%A1/</url>
      <content type="html"><![CDATA[<blockquote><p>因为工作的原因，需要查询资料，国内文档比较少，需要访问国外的网站，所以这里需要科学上网。本篇文章是搭建科学上网的服务端，搭建成功之后，客户端链接就可以尽情科学上网了。</p></blockquote><h2 id="安装具体步骤"><a href="#安装具体步骤" class="headerlink" title="安装具体步骤"></a>安装具体步骤</h2><ul><li>首先，你需要有一台海外的服务器，然后才能执行搭建服务。</li><li>我这里用的是Ubuntu系统，步骤非常简单，一步一步执行下面的命令就好</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">&lt;!-- 如果服务器没有安装git，需要执行这一步，安装git --&gt;</span><br><span class="line">sudo apt-get install git</span><br><span class="line">sudo apt-get install python-pip</span><br><span class="line">pip install git+https://github.com/shadowsocks/shadowsocks.git@master</span><br></pre></td></tr></table></figure><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><h4 id="直接启动"><a href="#直接启动" class="headerlink" title="直接启动"></a>直接启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json</span><br><span class="line">&lt;!-- 启动之后，ctrl+c就可以关闭服务 --&gt;</span><br></pre></td></tr></table></figure><h4 id="后台使用"><a href="#后台使用" class="headerlink" title="后台使用"></a>后台使用</h4><ul><li>在后台启动服务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json -d start</span><br><span class="line">ssserver -c /etc/shadowsocks.json -d stop</span><br></pre></td></tr></table></figure><p>至此，服务端已经搭建完成，直接在客户端链接就可以科学上网了。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>MongoDB数据库配合NodeJS简单使用</title>
      <link href="/2017/10/09/MongoDB%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2017/10/09/MongoDB%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h2 id="关于-MongoDB"><a href="#关于-MongoDB" class="headerlink" title="关于 MongoDB"></a>关于 MongoDB</h2><blockquote><p>  我们一般把数据库分为关系型数据库和非关系型数据库，MongoDB就是属于非关系型数据库的一种。</p></blockquote><ul><li>官网：<a href="https://www.mongodb.com/" target="_blank" rel="noopener">https://www.mongodb.com/</a></li><li>下载地址：<a href="https://www.mongodb.com/download-center?jmp=nav" target="_blank" rel="noopener">https://www.mongodb.com/download-center?jmp=nav</a></li></ul><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><ul><li><a href="https://www.smartftp.com/support/kb/the-program-cant-start-because-api-ms-win-crt-runtime-l1-1-0dll-is-missing-f2702.html?lang=zh-CN" target="_blank" rel="noopener">https://www.smartftp.com/support/kb/the-program-cant-start-because-api-ms-win-crt-runtime-l1-1-0dll-is-missing-f2702.html?lang=zh-CN</a></li><li><a href="http://stackoverflow.com/questions/33265663/api-ms-win-crt-runtime-l1-1-0-dll-is-missing-when-opening-microsoft-office-file" target="_blank" rel="noopener">http://stackoverflow.com/questions/33265663/api-ms-win-crt-runtime-l1-1-0-dll-is-missing-when-opening-microsoft-office-file</a></li></ul><h2 id="启动和关闭-MongoDB-数据库服务程序"><a href="#启动和关闭-MongoDB-数据库服务程序" class="headerlink" title="启动和关闭 MongoDB 数据库服务程序"></a>启动和关闭 MongoDB 数据库服务程序</h2><p>mongod.exe 是我们要启动的服务器文件<br>mongo的客户端去连我们的服务器</p><ul><li><p>打开终端，输入 <code>mongod</code> 回车</p><ul><li><code>mongod</code> 命令用来启动 MongoDB 数据服务</li><li>MongoDB 服务默认将 C:/data/db 目录作为数据目录</li><li>所以你需要先在 C:/ 根目录新建一个目录：C:/data/db</li><li>当你执行 mongod 命令的时候，默认会去使用 c:/data/db 目录作为数据存储目录</li><li>如果你不想使用 c:/data/db 目录</li><li>mongod –dbpath=路径</li></ul></li><li><p>32位操作系统启动 MongoDB</p><ul><li><a href="http://jingyan.baidu.com/article/76a7e409e1bb49fc3b6e1516.html" target="_blank" rel="noopener">http://jingyan.baidu.com/article/76a7e409e1bb49fc3b6e1516.html</a></li><li><code>mongod --dbpath 数据存储路径 --journal --storageEngine=mmapv1</code><br>mongod –dbpath C:/data/db –journal –storageEngine=mmapv1`</li></ul></li></ul><a id="more"></a><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ol><li>什么是数据？</li></ol><blockquote><p>数据是信息的表现形式和载体，可以是符号、文字、数字、语音、图像、视频等。通俗一点，数据就是信息，例如，个人信息、账户信息、家庭信息、企业信息、财务信息等等。</p></blockquote><ol start="2"><li>什么是数据库（Database，DB）？</li></ol><blockquote><p> 数据库是按照数据结构来组织、存储和管理数据的仓库。</p></blockquote><ol start="3"><li>为什么要使用数据库？</li></ol><blockquote><p>   我们需要使用数据库来存储我们网站的数据，然后通过增删改查进行数据交互，数据库，为我们提供了存储数据的仓库。</p></blockquote><ol start="4"><li>什么是数据库管理系统（DataBase Management System，DBMS）？</li></ol><blockquote><p> 数据库管理系统（DataBase Management System，DBMS）是为管理数据库而设计的大型电脑软件管理系统.例如，Oracle、Microsoft SQL Server、Access、MySQL、PostgreSQL、db2等等.我们可以简称这些数据库管理系统为数据库，虽然这种叫法不是很严谨，但是一般人都听的懂。</p></blockquote><ol start="5"><li>数据库的分类</li></ol><ul><li>关系型数据库 sql语言</li></ul><blockquote><p>关系数据库管理系统(Relational Database Management System)，<br>是将数据组织为相关的行和列的系统，而管理关系数据库的计算机软件就是关系数据库管理系统，常用的数据库软件有Oracle、SQL Server、MySQL等。</p></blockquote><ul><li>非关系型数据库 nosql<ul><li>内存数据库 redis</li><li>面向文档数据库 mongodb</li></ul></li></ul><h2 id="文档-document"><a href="#文档-document" class="headerlink" title="文档 document"></a>文档 document</h2><blockquote><p>文档是MongoDB中最基本的单元，里边包含多个键值对。</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;name:"zhangsan",age:12&#125;</span><br><span class="line">&#123;name:"lisi"&#125;</span><br></pre></td></tr></table></figure><h2 id="集合-collection"><a href="#集合-collection" class="headerlink" title="集合 collection"></a>集合 collection</h2><blockquote><p>集合就是一组文档，特点是动态模式，集合中每一个文档都有可能不一样。但是在实际开发中，最好我们保存一样格式的文档。</p></blockquote><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h4 id="1-列出所有的数据库"><a href="#1-列出所有的数据库" class="headerlink" title="1.  列出所有的数据库"></a>1.  列出所有的数据库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show dbs</span><br></pre></td></tr></table></figure><h4 id="2-进入或者新建数据库user"><a href="#2-进入或者新建数据库user" class="headerlink" title="2.  进入或者新建数据库user"></a>2.  进入或者新建数据库user</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use user</span><br><span class="line">//如果已经有了user数据库，就会进入user数据库</span><br><span class="line">//如果没有user数据库，就会自动新建数据库，如果数据库中没有任何文档，则用show dbs不会显示该仓库</span><br></pre></td></tr></table></figure><h4 id="3-新建文档"><a href="#3-新建文档" class="headerlink" title="3.  新建文档"></a>3.  新建文档</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.user.insert(&#123;name:<span class="string">"wang"</span>&#125;)</span><br><span class="line">//在user集合中添加一条文档数据</span><br></pre></td></tr></table></figure><h4 id="4-查看user集合中的文档"><a href="#4-查看user集合中的文档" class="headerlink" title="4.  查看user集合中的文档"></a>4.  查看user集合中的文档</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.user.find()</span><br></pre></td></tr></table></figure><h4 id="5-更新文档内容"><a href="#5-更新文档内容" class="headerlink" title="5.  更新文档内容"></a>5.  更新文档内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.user.update(&#123;name:<span class="string">"wang"</span>&#125;,&#123;<span class="variable">$set</span>:&#123;name:<span class="string">"ang"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><h4 id="6-删除文档"><a href="#6-删除文档" class="headerlink" title="6.  删除文档"></a>6.  删除文档</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.user.remove(&#123;name:<span class="string">"wang"</span>&#125;)</span><br><span class="line">//如果不传入参数，则会直接删除集合</span><br></pre></td></tr></table></figure><h3 id="7-删除数据库"><a href="#7-删除数据库" class="headerlink" title="7.  删除数据库"></a>7.  删除数据库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use user</span><br><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure><h2 id="js链接MongoDb"><a href="#js链接MongoDb" class="headerlink" title="js链接MongoDb"></a>js链接MongoDb</h2><blockquote><p> mongodb包提供的方法api和monggodb的命令基本一样，我们可以在nodejs中使用mongodb数据库进行增删改查操作。</p></blockquote><ul><li>api地址：<a href="http://mongodb.github.io/node-mongodb-native/2.2/api" target="_blank" rel="noopener">http://mongodb.github.io/node-mongodb-native/2.2/api</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
            <tag> NodeJS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux安装mongodb</title>
      <link href="/2017/09/26/linux%E5%AE%89%E8%A3%85mongodb/"/>
      <url>/2017/09/26/linux%E5%AE%89%E8%A3%85mongodb/</url>
      <content type="html"><![CDATA[<h1 id="Linux下安装MongoDB"><a href="#Linux下安装MongoDB" class="headerlink" title="Linux下安装MongoDB"></a>Linux下安装MongoDB</h1><h2 id="一、MongoDB的安装"><a href="#一、MongoDB的安装" class="headerlink" title="一、MongoDB的安装"></a>一、MongoDB的安装</h2><ol><li>下载安装包</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  - 下载方式：</span></span><br><span class="line">curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.6.4.tgz</span><br><span class="line"><span class="comment"># - 解压缩压缩包：</span></span><br><span class="line">tar zxvf mongodb-linux-x86_64-3.6.4.tgz</span><br></pre></td></tr></table></figure><ol start="2"><li>安装准备</li></ol><ul><li><p>创建数据库文件夹与日志文件、配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p  /usr/<span class="built_in">local</span>/server/mongodb/data</span><br><span class="line">touch /usr/<span class="built_in">local</span>/server/mongodb/mongod.log</span><br><span class="line">touch /usr/<span class="built_in">local</span>/server/mongodb/mongodb.conf</span><br></pre></td></tr></table></figure></li><li><p>将mongodb移动到/usr/local/server/mongdb文件夹：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv mongodb-linux-x86_64-3.6.4/*  /usr/<span class="built_in">local</span>/server/mongodb</span><br></pre></td></tr></table></figure><ol start="3"><li>启动mongodb(有两种方式)</li></ol><ul><li>参数启动：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#   参数启动可以直接在命令后面加配置参数，也可以加配置文件启动，如下加配置参数启动：</span></span><br><span class="line">./mongod --dbpath=/usr/<span class="built_in">local</span>/server/mongodb/data --logpath=/usr/<span class="built_in">local</span>/server/mongodb/mongod.log --logappend  --port=27017 --fork</span><br></pre></td></tr></table></figure><ul><li><p>如果在配置文件中配置好各项参数，则可以使用配置文件启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./mongod --config /usr/<span class="built_in">local</span>/server/mongodb/mongodb.conf</span><br><span class="line">mongod -f mongodb.conf</span><br></pre></td></tr></table></figure></li><li><p>mongodb.conf</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">dbpath=/usr/local/server/mongodb/data</span> <span class="comment">#数据库路径</span></span><br><span class="line"><span class="string">logpath=/usr/local/server/mongodb/mongodb.log</span> <span class="comment">#日志输出文件路径</span></span><br><span class="line"><span class="string">logappend=true</span> <span class="comment">#错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件</span></span><br><span class="line"><span class="string">journal=true</span> <span class="comment">#启用日志文件，默认启用</span></span><br><span class="line"><span class="string">quiet=true</span> <span class="comment">#这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false</span></span><br><span class="line"><span class="string">port=27017</span> <span class="comment">#端口号 默认为27017</span></span><br></pre></td></tr></table></figure><ul><li>加入系统路径变量<br>注：可以将mongodb临时加入系统路径变量中，这样可以不用输入路径直接启动，代码如下：<br>export PATH=/usr/local/server/mongodb/bin:$PATH<br>然后可以查看是否成功：echo $PATH</li></ul><h2 id="二、用户授权和管理"><a href="#二、用户授权和管理" class="headerlink" title="二、用户授权和管理"></a>二、用户授权和管理</h2><ol><li>mongodb安装好后第一次进入是不需要密码的，也没有任何用户，通过shell命令可直接进入，cd到mongodb目录下的bin文件夹，执行命令./mongo即可</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@namenode mongodb]<span class="comment"># ./bin/mongo</span></span><br><span class="line">MongoDB shell version: 1.8.2</span><br><span class="line">connecting to: <span class="built_in">test</span></span><br><span class="line">&gt; use <span class="built_in">test</span>;</span><br><span class="line">switched to db <span class="built_in">test</span></span><br></pre></td></tr></table></figure><ol start="2"><li>添加管理用户（mongoDB 没有无敌用户root，只有能管理用户的用户 userAdminAnyDatabase）,</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;use admin</span><br><span class="line">&gt;db.createUser( &#123;user: <span class="string">"admin"</span>,<span class="built_in">pwd</span>: <span class="string">"123456"</span>,roles: [ &#123; role: <span class="string">"userAdminAnyDatabase"</span>, db: <span class="string">"admin"</span> &#125; ]&#125;)</span><br></pre></td></tr></table></figure><ul><li>注：添加完用户后可以使用show users或db.system.users.find()查看已有用户</li></ul><ol start="3"><li><p>添加完管理用户后，关闭MongoDB，并使用权限方式再次开启MongoDB，这里注意不要使用kill直接去杀掉mongodb进程，（如果这样做了，请去data/db目录下删除mongo.lock文件），可以使用db.shutdownServer()关闭</p></li><li><p>使用权限方式启动MongoDB</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./mongod --dbpath=/usr/<span class="built_in">local</span>/server/mongodb/data --logpath=/usr/<span class="built_in">local</span>/server/mongodb/mongod.log --fork --auth</span><br><span class="line">或者在配置文件中修改：</span><br><span class="line"> auth = <span class="literal">true</span></span><br><span class="line"><span class="comment">#noauth = true</span></span><br></pre></td></tr></table></figure><ol start="5"><li>进入mongo shell，使用admin数据库并进行验证，如果不验证，是做不了任何操作的。 </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; use admin</span><br><span class="line">&gt; db.auth(<span class="string">"admin"</span>,<span class="string">"123456"</span>)   <span class="comment">#认证，返回1表示成功</span></span><br></pre></td></tr></table></figure><ol start="6"><li>验证之后还是做不了操作，因为admin只有用户管理权限，下面创建用户，用户都跟着库走，</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; use mydb</span><br><span class="line">&gt; db.createUser(&#123;user: <span class="string">"root"</span>,<span class="built_in">pwd</span>: <span class="string">"123456"</span>,roles: [&#123; role: <span class="string">"readWrite"</span>, db: <span class="string">"mydb"</span> &#125;]&#125;)</span><br></pre></td></tr></table></figure><ol start="7"><li>使用创建的用户root登录进行数据库操作：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mongodb]<span class="comment"># mongo 127.0.0.1/mydb -uroot -p</span></span><br><span class="line">MongoDB shell version: 3.2.9</span><br><span class="line">Enter password:</span><br><span class="line">connecting to: 127.0.0.1/mydb</span><br><span class="line">&gt; db</span><br><span class="line">mydb</span><br><span class="line">&gt; use mydb</span><br><span class="line">switched to db mydb</span><br><span class="line">&gt; show collections</span><br></pre></td></tr></table></figure><p>然后就可以进行增删改查各种数据操作…</p>]]></content>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>css变形</title>
      <link href="/2017/07/11/css%E5%8F%98%E5%BD%A2/"/>
      <url>/2017/07/11/css%E5%8F%98%E5%BD%A2/</url>
      <content type="html"><![CDATA[<h1>css变形</h1><blockquote><p>  我们可以借助css3实现图片元素的倾斜、缩放、移动、以及翻转效果。</p></blockquote><h2 id="1-tranfrom属性语法"><a href="#1-tranfrom属性语法" class="headerlink" title="1.  tranfrom属性语法"></a>1.  tranfrom属性语法</h2><blockquote><p>  tranfrom属性让元素在一个坐标系统中变形，包含一系列变形函数，可以移动、旋转和缩放元素。</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transfrom: none | &lt;transfrom-function&gt;</span><br></pre></td></tr></table></figure><ul><li>默认值为:none,表示不对元素进行变形;</li><li>也可以指定一个或者多个变形函数，以空格分开。如：rotate、scale、trasnslate;</li></ul><h2 id="2-变形函数介绍"><a href="#2-变形函数介绍" class="headerlink" title="2.  变形函数介绍"></a>2.  变形函数介绍</h2><a id="more"></a><blockquote><p>  所有的2D变形函数可以应用于3D变形规范中。</p></blockquote><pre><code>函数 | 功能描述----|-------translate() | 移动元素，可以根据X轴和Y轴坐标重新定位自己的位置，有tranlateX(),translateY()scale() | 缩小或者方法元素，可以使元素尺寸发生变化，有scaleX()和scaleY()rotate() | 旋转元素skew() | 让元素倾斜，在此基础上有两个扩展函数，skewX()和skewY()matrix()|定义矩阵变形，基于X轴和Y轴坐标重新定位元素位置</code></pre>]]></content>
      
      
        <tags>
            
            <tag> css3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前后端渲染的对比</title>
      <link href="/2017/05/14/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%B8%B2%E6%9F%93%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
      <url>/2017/05/14/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%B8%B2%E6%9F%93%E7%9A%84%E5%AF%B9%E6%AF%94/</url>
      <content type="html"><![CDATA[<blockquote><p>  服务端渲染是通过后端模板引擎编译成html,css,js,然后回传给前端来进行显示；而前端渲染则是将整个生成逻辑代码全部回传前端，再由客户端生成用户界面。</p></blockquote><h2 id="为什么会有服务端渲染与客户端渲染"><a href="#为什么会有服务端渲染与客户端渲染" class="headerlink" title="为什么会有服务端渲染与客户端渲染"></a>为什么会有服务端渲染与客户端渲染</h2><p>早期，我们每一个页面都是直接由html，css，js实现的，每一个页面彼此之间相当于是独立的，当我们的网站应用足够大的时候，每当我们需要修改网站的内容时，我们需要更改很多的代码，非常麻烦。</p><p>那么后来，我们聪明的程序员就想到了，使用代码生成代码，就是后端的模板引擎，人们开始广泛使用模板代替手写html，大大减少的前端的工作量。通过代码生成代码，其实就是编译，基于html等基础语言，做出了更高层次的抽象封装，增加了易用性。</p><p>后来h5,c3的崛起，再加上客户端硬件性能的提升，我们开始通过前端模板引擎，来在客户端渲染页面。</p><p>对待模板，angular，vue，react的态度都不一样。</p><a id="more"></a><p><strong>前后端真正解耦，前端专注于UI视图,后台专注于数据处理，通过设计好的api交互，这是未来的趋势。</strong></p><h2 id="从-后端渲染-到-前端渲染-，有什么变化"><a href="#从-后端渲染-到-前端渲染-，有什么变化" class="headerlink" title="从 后端渲染 到 前端渲染 ，有什么变化"></a>从 后端渲染 到 前端渲染 ，有什么变化</h2><ul><li>计算任务的变化</li></ul><blockquote><p>  原来由后端执行的渲染任务，现在放在了前端来做，降低了多用户同时访问时服务端的压力，然后端专注做后端的事情，由于客户端硬件的发展，前端处理起来没有什么问题。</p></blockquote><ul><li>放弃前端权限</li></ul><blockquote><p>  将整个页面逻辑，交给客户端以后，会出现劫持的情况，比如某些运营商劫持之后，投放广告。俗话说的好<strong>一切在前端谈安全都是耍流氓</strong>，后端不能轻信前端发来的数据，一切数据都需要过滤与验证，最好使用ssl，屏蔽XSS。</p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><strong>总之一句话，后端渲染针对seo比较友好，前端渲染，可以减轻服务端的压力，提升服务器的性能，而且可以实现前后端分离！</strong></p>]]></content>
      
      
        <tags>
            
            <tag> 服务端渲染 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ubuntu常用软件部署</title>
      <link href="/2017/04/02/ubuntu%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E9%83%A8%E7%BD%B2/"/>
      <url>/2017/04/02/ubuntu%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[<h1 id="ubuntu中快速安装nodejs"><a href="#ubuntu中快速安装nodejs" class="headerlink" title="ubuntu中快速安装nodejs"></a>ubuntu中快速安装nodejs</h1><h2 id="1-我们可以直接通过apt-get安装nodejs"><a href="#1-我们可以直接通过apt-get安装nodejs" class="headerlink" title="1.  我们可以直接通过apt-get安装nodejs"></a>1.  我们可以直接通过<code>apt-get</code>安装nodejs</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update //需要先刷新本地索引包</span><br><span class="line">sudo apt-get install nodejs //然后安装nodejs包</span><br><span class="line">sudo apt-get install npm    //安装npm包管理器</span><br></pre></td></tr></table></figure><h2 id="2-安装好的node版本较低，我们可以使用n模块升级node到你需要打版本"><a href="#2-安装好的node版本较低，我们可以使用n模块升级node到你需要打版本" class="headerlink" title="2. 安装好的node版本较低，我们可以使用n模块升级node到你需要打版本"></a>2. 安装好的node版本较低，我们可以使用n模块升级node到你需要打版本</h2><h4 id="1-node有一个-n模块，专门用来管理nodejs版本的。不过目前并不支持windows系统。我们先安装下"><a href="#1-node有一个-n模块，专门用来管理nodejs版本的。不过目前并不支持windows系统。我们先安装下" class="headerlink" title="1.  node有一个 n模块，专门用来管理nodejs版本的。不过目前并不支持windows系统。我们先安装下"></a>1.  node有一个 n模块，专门用来管理nodejs版本的。不过目前并不支持windows系统。我们先安装下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g n</span><br></pre></td></tr></table></figure><h4 id="2-升级到制定版本，我们可以在n加上指定的版本号就可以"><a href="#2-升级到制定版本，我们可以在n加上指定的版本号就可以" class="headerlink" title="2.  升级到制定版本，我们可以在n加上指定的版本号就可以"></a>2.  升级到制定版本，我们可以在n加上指定的版本号就可以</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo n 6.10.2</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="3-还有一些常用打快捷方法"><a href="#3-还有一些常用打快捷方法" class="headerlink" title="3.  还有一些常用打快捷方法"></a>3.  还有一些常用打快捷方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo n latest   //安装最新打官方版本</span><br><span class="line">sudo n stanle   //安装最新打稳定版</span><br><span class="line">sudo n lts      //安装最新打lts官方版</span><br></pre></td></tr></table></figure><h4 id="4-删除版本"><a href="#4-删除版本" class="headerlink" title="4.  删除版本"></a>4.  删除版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo n rm 0.9.4</span><br><span class="line">sudo n -0.9.4</span><br></pre></td></tr></table></figure><ul><li>更多命令，我们可以使用<code>n --help</code>寻求帮助</li></ul><h1 id="ubuntu常用工具安装"><a href="#ubuntu常用工具安装" class="headerlink" title="ubuntu常用工具安装"></a>ubuntu常用工具安装</h1><h2 id="右上角任务栏显示cpu内存使用百分比，还可以显示网络传输速率"><a href="#右上角任务栏显示cpu内存使用百分比，还可以显示网络传输速率" class="headerlink" title="右上角任务栏显示cpu内存使用百分比，还可以显示网络传输速率"></a>右上角任务栏显示cpu内存使用百分比，还可以显示网络传输速率</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitor   //这里选择按enter键</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install indicator-sysmonitor</span><br><span class="line">//启动</span><br><span class="line">indicator-sysmonitor &amp;</span><br><span class="line">//ctrl+c后台运行该程序</span><br></pre></td></tr></table></figure><ul><li>启动之后，最好让程序开机自启动，鼠标右键点击标题栏上图标，弹出菜单，把<code>run on startup</code>后边打勾打上，然后进去advanced选项卡，就可以自定义配置需要显示在任务栏的项目啦</li></ul><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br><span class="line">git config --global user.name &quot;name&quot;</span><br><span class="line">git config --global user.email &quot;your@email.com&quot;</span><br></pre></td></tr></table></figure><h2 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure><h2 id="安装yarn包管理工具"><a href="#安装yarn包管理工具" class="headerlink" title="安装yarn包管理工具"></a>安装yarn包管理工具</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g yarn</span><br></pre></td></tr></table></figure><h2 id="安装cnpm镜像源"><a href="#安装cnpm镜像源" class="headerlink" title="安装cnpm镜像源"></a>安装cnpm镜像源</h2><blockquote><p>  下载包直接可以使用 <code>cnpm install name</code> 下载</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g cnpm</span><br></pre></td></tr></table></figure><h2 id="安装nrm，node下载数据源管理器"><a href="#安装nrm，node下载数据源管理器" class="headerlink" title="安装nrm，node下载数据源管理器"></a>安装nrm，node下载数据源管理器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g nrm</span><br><span class="line">nrm -v //查看安装版本验证是否安装成功</span><br></pre></td></tr></table></figure><h4 id="可以查看当前所有的下载数据源链接"><a href="#可以查看当前所有的下载数据源链接" class="headerlink" title="可以查看当前所有的下载数据源链接"></a>可以查看当前所有的下载数据源链接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nrm ls</span><br></pre></td></tr></table></figure><h4 id="测试所有打镜像源的响应速度，然后根据测试我们可以切换我们需要使用的下载源"><a href="#测试所有打镜像源的响应速度，然后根据测试我们可以切换我们需要使用的下载源" class="headerlink" title="测试所有打镜像源的响应速度，然后根据测试我们可以切换我们需要使用的下载源"></a>测试所有打镜像源的响应速度，然后根据测试我们可以切换我们需要使用的下载源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nrm test</span><br><span class="line">nrm use [taobao]</span><br></pre></td></tr></table></figure><h1 id="github使用ssh"><a href="#github使用ssh" class="headerlink" title="github使用ssh"></a>github使用ssh</h1><blockquote><p>  我们使用git去github上传东西，一般都使用ssh免密方式，所以需要首先生成一枚ssh-key密钥，然后在home文件夹进入个人文件夹中，按ctrl+h，会显示所有隐藏文件，打开.ssh文件夹中的id_rsa.pub文件，把里边内容粘贴到github上就可以啦</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;wangpansheng@qq.com&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ubuntu常见问题处理</title>
      <link href="/2017/04/02/ubuntu%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2017/04/02/ubuntu%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="常见问题处理"><a href="#常见问题处理" class="headerlink" title="常见问题处理"></a>常见问题处理</h2><h3 id="1-win10和ubuntu双系统时，硬盘无法加载问题"><a href="#1-win10和ubuntu双系统时，硬盘无法加载问题" class="headerlink" title="1.  win10和ubuntu双系统时，硬盘无法加载问题"></a>1.  win10和ubuntu双系统时，硬盘无法加载问题</h3><ul><li><p>需要依赖于ntfs-3g，如果没有需要先安装这个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ntfs-3g</span><br></pre></td></tr></table></figure></li><li><p>然后只用ntfsfix修复，即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ntfsfix /绝对路径</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h2 id="常用软件推荐"><a href="#常用软件推荐" class="headerlink" title="常用软件推荐"></a>常用软件推荐</h2><h3 id="1-图片处理-GIMP"><a href="#1-图片处理-GIMP" class="headerlink" title="1.   图片处理:GIMP"></a>1.   图片处理:GIMP</h3><ul><li>对于非专业性的图片处理，该款APP已经十分足够了，功能也挺丰富、强大的。</li></ul><h3 id="2-视频播放：VLC"><a href="#2-视频播放：VLC" class="headerlink" title="2.  视频播放：VLC"></a>2.  视频播放：VLC</h3><ul><li>能够播放rmvb、mp4、avi等多种格式的视频文件，支持快速播放等功能。</li><li>安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository ppa:videolan/stable-daily</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install vlc</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-启动栏：Docky"><a href="#3-启动栏：Docky" class="headerlink" title="3.  启动栏：Docky"></a>3.  启动栏：Docky</h3><ul><li>ndicator-sysmonitor 这是一款能够实时查看当前系统的CPU、内存、网络、IP等信息</li></ul>]]></content>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>centos-01</title>
      <link href="/2017/03/03/centos-01/"/>
      <url>/2017/03/03/centos-01/</url>
      <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//查看当前centos系统的版本</span><br><span class="line">cat /etc/redhat-release</span><br><span class="line">//查看系统内核版本是32位还是64位</span><br><span class="line">uname -r</span><br><span class="line">//安装cnpm</span><br><span class="line">npm install cnpm -g --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></code></pre><h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><blockquote><p>  在企业生产中，一般不会直接使用root来操作，可以通过命令创建用户，并且进行切换，普通用户下，前边显示的是$符号，root下显示的是#</p></blockquote><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useradd username    //添加用户名</span><br><span class="line">passwd username     //给刚才添加的用户，设置密码，然后会提示输入密码，输入两次就可以了</span><br><span class="line">su - username       //可以切换到指定的用户</span><br><span class="line">su - root           //可以切换到root</span><br><span class="line">whoami              //可以查看当前用户是谁</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> centos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NodeJS构建express框架开发简单应用</title>
      <link href="/2017/01/10/nodeJS%E6%9E%84%E5%BB%BAexpress%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
      <url>/2017/01/10/nodeJS%E6%9E%84%E5%BB%BAexpress%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<blockquote><p>  使用node express简单构建，配合MongoDB数据库，实现简单的增删改查操作</p></blockquote><h2 id="首先我们需要构建express本地框架结构"><a href="#首先我们需要构建express本地框架结构" class="headerlink" title="首先我们需要构建express本地框架结构"></a>首先我们需要构建express本地框架结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">express demo</span><br><span class="line">//在demo文件夹中构建express结构</span><br></pre></td></tr></table></figure><h2 id="然后我们运行一下，"><a href="#然后我们运行一下，" class="headerlink" title="然后我们运行一下，"></a>然后我们运行一下，</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><p>执行之后，我们在浏览器打开localhost:3000就可以看到初始化的页面，</p><h2 id="因为我们是使用-MongoDb数据库，所以需要安装mongodb的nodeJS包，"><a href="#因为我们是使用-MongoDb数据库，所以需要安装mongodb的nodeJS包，" class="headerlink" title="因为我们是使用 MongoDb数据库，所以需要安装mongodb的nodeJS包，"></a>因为我们是使用 MongoDb数据库，所以需要安装mongodb的nodeJS包，</h2><p>mongodb包的api基本上mongodb数据库的命令行操作命令差不多，所以，如果你比较清楚命令行操作命令，使用起来就会非常方便，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//安装mongodb包</span><br><span class="line">npm install mongodb --save</span><br><span class="line">//安装依赖包</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>至此，所有的准备工作基本完成，当然，前提你已经装好mongodb数据库，而且在使用的时候，需要全程开启数据库服务器。mongodb数据库的安装，我以前有文章有介绍过，有兴趣的可以去看看。</p><h2 id="我们使用MVC架构来实现针对数据库的增删改查，"><a href="#我们使用MVC架构来实现针对数据库的增删改查，" class="headerlink" title="我们使用MVC架构来实现针对数据库的增删改查，"></a>我们使用MVC架构来实现针对数据库的增删改查，</h2><ul><li>我们创建一个文件夹 module，就是连接控制数据库的文件。</li><li>我们使用routes来代替controller同样的功能，来连接视图层和数据库的连接。</li><li>我们的整体逻辑是，我们路由中添加一个get请求，请求中调用module中的一个操作方法，然后module中的添加方法，再去调用数据库连接，然后在使用操作api操作数据库。<h2 id="在module中首先连接到数据库"><a href="#在module中首先连接到数据库" class="headerlink" title="在module中首先连接到数据库"></a>在module中首先连接到数据库</h2></li></ul><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到MongoClient对象</span></span><br><span class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">"mongodb"</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"数据库主机ip:port/数据库名"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    MongoClient.connect(url,<span class="function"><span class="keyword">function</span>(<span class="params">err,db</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="comment">//代表连接失败</span></span><br><span class="line">        <span class="keyword">return</span> callback(err);</span><br><span class="line">        &#125;</span><br><span class="line">        callback(<span class="literal">null</span>,db)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> NodeJS express </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数组方法梳理</title>
      <link href="/2016/11/26/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%A2%B3%E7%90%86/"/>
      <url>/2016/11/26/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%A2%B3%E7%90%86/</url>
      <content type="html"><![CDATA[<p><img src="/images/bg2.jpg" alt="images/bg2.jpg"></p><blockquote><p>  由于发现对数组和字符串原生的方法有点记不太清了，所以打算梳理一下，把这写方法整理一下，加强自己的记忆。</p></blockquote><blockquote><p>  以下数组演示都以数组 数组arr=[1,2,3]为原始值；</p></blockquote><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><ul><li><p>返回数组的长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.length;<span class="comment">//返回值是3</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><ul><li><p>连接两个或更多数组，并返回新数组，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.concat([<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//返回是数组[1,2,3,8,9,0]</span></span><br><span class="line"><span class="comment">//不会修改原数组</span></span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><ul><li><p>把数组的所有元素放进一个新的字符串，元素根据指定的字符串分割</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.join(<span class="string">""</span>);</span><br><span class="line"><span class="comment">//返回值是字符串123</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h3><ul><li><p>删除并返回最后一个元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.pop();</span><br><span class="line"><span class="comment">//从数组中删除最后一个元素</span></span><br><span class="line"><span class="comment">//返回值是删除的元素，</span></span><br><span class="line"><span class="comment">//原数组被更改</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h3><ul><li>向数组最后添加一个或多个元素，并返回添加之后数组的长度<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr.push(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//返回值是新数组长度</span></span><br><span class="line"><span class="comment">//原数组被更改</span></span><br><span class="line">arr.push([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="comment">//这样调用，会把传入的数组当作数组一个元素</span></span><br><span class="line">arr.push(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"><span class="comment">//会把传入的值按照先后顺序放在数组的最后</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><ul><li><p>颠倒数组中元素的排序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.reverse();</span><br><span class="line"><span class="comment">//返回值和原数组都是反转之后的数组</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h3><ul><li><p>删除并返回数组的第一个元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.shift();</span><br><span class="line"><span class="comment">//返回被删除的元素</span></span><br><span class="line"><span class="comment">//会修改原数组</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h3><ul><li>在数组最前添加一个或多个元素，返回新长度<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.unshift([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line">arr.unshift(<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"><span class="comment">//如果传入多个元素，传入的第一个元素会在数组的索引0上，第二个会在1上，以此类推，</span></span><br><span class="line"><span class="comment">//简单理解，传入多个元素，直接把传入的内容直接放在最前边；</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><ul><li><p>选取并返回数组中指定的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr.slice(start,end);</span><br><span class="line"><span class="comment">//strat是开始索引值，end是结束索引值，不包含end索引的值</span></span><br><span class="line"><span class="comment">//如果索引值是负数，-1就是最后一个元素，以此类推</span></span><br><span class="line"><span class="comment">//如果没有第二个值，那么从start开始截取到数组结束</span></span><br><span class="line"><span class="comment">//不会修改原元素</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><ul><li><p>对数组的元素进行排序,直接对原数组进行排序，返回值也是排序后的新数组,如果不传参数，则是按照元素首字母排序，如果需要按照指定的规则排序，需要传入指定的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.sort();</span><br></pre></td></tr></table></figure></li></ul><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><ul><li><p>从数组中添加删除元素，返回被删除的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr.splice(index,howmany,item1...itemx); </span><br><span class="line"><span class="comment">//index 添加或删除元素的索引位置</span></span><br><span class="line"><span class="comment">//howmany 要删除元素的个数，不删除可以设置为0</span></span><br><span class="line"><span class="comment">//item 要添加的元素</span></span><br><span class="line"><span class="comment">//返回值是删除的元素</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="toSource"><a href="#toSource" class="headerlink" title="toSource()"></a>toSource()</h3><ul><li>返回对象的源代码,只有火狐支持</li></ul><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><ul><li>把数组转换为字符串，并返回结果</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 数组，js基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>原生框架封装之插件开发</title>
      <link href="/2016/11/20/%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85%E4%B9%8B%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
      <url>/2016/11/20/%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85%E4%B9%8B%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ol><li><p>历史背景</p><ul><li>http https: 都是一种无状态、无连接的协议</li><li>tcp/ip 是一种长连接协议</li><li>无论什么用户都可以访问网址页面，在实际开发中，有些页面需要先验证身份才可以访问的，此时就需要http记录用户的状态，（登录状态），</li><li>但是http协议是无状态的，因此就诞生了session和cookie</li></ul></li><li><p>应用场景</p><ul><li>登录功能：记录登录状态，以及一些用户基本信息。</li><li>用户基本信息：昵称、头像地址、加密后的密码（记住密码）、用户名</li></ul></li><li><p>做cookie插件的目的</p></li></ol><ul><li>方便前端人员操作cookie</li></ul><a id="more"></a><h2 id="原生js操作cookie"><a href="#原生js操作cookie" class="headerlink" title="原生js操作cookie"></a>原生js操作cookie</h2><ol><li><p>获取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie</span><br></pre></td></tr></table></figure></li><li><p>操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"username=guoguo"</span>;</span><br></pre></td></tr></table></figure></li><li><p>设置有效期</p><ul><li><p>默认如果没有设置cookie有效期，它就是一个会话的cookie，也就是说，当浏览器关闭时，该cookie的信息会被清除掉</p></li><li><p>在设置cookie有效期时，单位是天，在原生设置cookie有效期时，要给expiries赋值为截止日期；</p></li></ul></li><li><p>设置域名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">domain=<span class="string">"xxx.com"</span></span><br></pre></td></tr></table></figure></li><li><p>设置路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path=<span class="string">"/"</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
        <tags>
            
            <tag> 原生框架封装 </tag>
            
            <tag> js，jquery </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jqeury框架封装练习3</title>
      <link href="/2016/11/18/%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85%E7%BB%83%E4%B9%A03/"/>
      <url>/2016/11/18/%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85%E7%BB%83%E4%B9%A03/</url>
      <content type="html"><![CDATA[<h2 id="DOM操作模块"><a href="#DOM操作模块" class="headerlink" title="DOM操作模块"></a>DOM操作模块</h2><h3 id="appendTO方法"><a href="#appendTO方法" class="headerlink" title="appendTO方法"></a>appendTO方法</h3><ol><li><p>语法：实例对象.appendTo(target);</p></li><li><p>功能：将调用者上的所有DOM元素，分别追加到目标元素上</p></li><li><p>target参数类型：</p><ul><li>选择器</li><li>DOM元素</li><li>DOM数组，伪数组</li></ul></li></ol><ul><li><p>为了更方便处理不同的类型，在实现时，首先统一target的参数类型，方便发i吗逻辑的处理</p></li><li><p>将target统一成itcast的对象，参数一致，便于处理，同时由于是itcast对象，就可以直接调用each方法进行遍历元素</p></li></ul><ol start="4"><li>实现思路</li></ol><ul><li>统一target类型，</li><li>遍历target，再遍历调用者</li><li>判断，当目标元素是不是第一个元素，如果是，不需要拷贝源节点，否则就要深拷贝源节点，</li><li>将上述得到的新节点，缓存起来到数组中，</li><li>再将新节点追加到dom元素中</li><li>将缓存的数组转换成itcast对象，作为appendTo的返回值，来实现链式编程。</li></ul><a id="more"></a><h3 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h3><ol><li><p>功能：    将传入参数追加给调用者。</p></li><li><p>思路：</p><ul><li>将传入实参转换成itcast对象</li><li>用传入的实参调用appendTo方法，将this作为目标元素传入appendTo方法</li><li>实现链式编程</li></ul></li></ol>]]></content>
      
      
        <tags>
            
            <tag> 原生框架 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>框架封装之Ajax</title>
      <link href="/2016/11/17/%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85%E4%B9%8BAjax/"/>
      <url>/2016/11/17/%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85%E4%B9%8BAjax/</url>
      <content type="html"><![CDATA[<h2 id="ajax请求步骤"><a href="#ajax请求步骤" class="headerlink" title="ajax请求步骤"></a>ajax请求步骤</h2><ol><li>创建请求对象</li><li>格式化数据</li><li>与服务器建立连接</li><li>监听请求状态</li><li>发送请求</li></ol><h2 id="创建请求对象"><a href="#创建请求对象" class="headerlink" title="创建请求对象"></a>创建请求对象</h2><ol><li>原生方法<ul><li>w3c:XMLHttpRequest</li><li>IE：ActiveXObject</li></ul></li></ol><h2 id="封装Ajax模块"><a href="#封装Ajax模块" class="headerlink" title="封装Ajax模块"></a>封装Ajax模块</h2><ol><li><p>确定Ajax配置的默认值</p><ul><li>url =&gt; “”</li><li>type =&gt; “get”</li><li>data =&gt; {}</li><li>success =&gt; null</li><li>fail =&gt; null</li><li>async =&gt; true</li><li>dataType =&gt; “json”</li><li>contentType =&gt; “application/x-www-form-ulencoded”</li></ul></li><li><p>ajax默认配置放在哪？</p><ul><li>要用一个对象来存储上述Ajax配置信息，像jQuery一样，将其放到工厂函数上；<br>放在工厂函数jq上</li></ul></li></ol><a id="more"></a><h3 id="改造extend方法"><a href="#改造extend方法" class="headerlink" title="改造extend方法"></a>改造extend方法</h3><ol><li>如果只传入一个参数，给this扩展成员，</li><li>或者传入两个以上，就是给第一个参数扩展成员，，</li></ol><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><ol><li><p>jsonp跨域的一种方式，缺点：只能发送跨域get请求</p></li><li><p>本质：利用script标签的src属性可以跨域的特性</p></li><li><p>实现流程：</p><ul><li>创建script标签，添加到head下</li><li>常见一个全局函数，用来处理服务器响应的数据</li><li>指定script标签src的属性值，同时将全局函数发送到服务区</li><li>要与后台人员沟通，将发送全局函数的参数名告诉后台人员</li><li></li></ul></li><li>实现步骤：<ul><li>常见请求对象，script标签</li><li>格式化数据</li><li>创建一个全局函数，将函数添加到data内，</li><li>监听请求的状态-》使用timeout来做请求状态的监听，如果在超过时间内，表示成功，否则就报超时，</li><li>发送请求，-》给script标签指定src属性值</li></ul></li></ol>]]></content>
      
      
        <tags>
            
            <tag> 框架封装，ajax </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>原生框架封装练习02</title>
      <link href="/2016/11/17/%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85%E7%BB%83%E4%B9%A02/"/>
      <url>/2016/11/17/%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85%E7%BB%83%E4%B9%A02/</url>
      <content type="html"><![CDATA[<h2 id="工具类方法与功能类方法"><a href="#工具类方法与功能类方法" class="headerlink" title="工具类方法与功能类方法"></a>工具类方法与功能类方法</h2><ol><li><p>工具类方法：</p><ul><li>可以在内部使用，也可以给使用者使用，不需要常见实例就可以调用的</li></ul></li><li><p>功能类方法：</p><ul><li>框架内部的对象的方法，必须使用该对象去调用，操作dom元素的方法</li></ul></li></ol><h2 id="类型判断方法"><a href="#类型判断方法" class="headerlink" title="类型判断方法"></a>类型判断方法</h2><ol><li><p>isString方法：判断指定 参数是不是字符串类型，</p></li><li><p>isHTML：判断指定参数是不是html字符串</p><ul><li>以&lt;开头，以&gt;结尾，长度不小于3的字符串</li></ul></li><li><p>isDOM：判断指定的参数是不是dom对象</p><ul><li>如果参数不为null或undefined，并且具有nodetype属性，那么类型就是dom对象</li></ul></li><li><p>isArrayLink：判断指定参数是不是数组或伪数组</p><ul><li>如果对象的length属性是number类型</li></ul></li></ol><a id="more"></a><ol start="5"><li><p>isFunction：</p><ul><li></li></ul></li><li><p>iswindow：判断指定参数是不是window</p><ul><li>如果参数值不是null undefined，并具有window属性指向自己，那么该对象就是window</li></ul></li></ol><h2 id="工具类方法"><a href="#工具类方法" class="headerlink" title="工具类方法"></a>工具类方法</h2><ol><li><p>type方法：</p></li><li><p>ParseHTML方法：将html字符串转换为对应的元素节点</p></li></ol><h2 id="selector参数类型与逻辑"><a href="#selector参数类型与逻辑" class="headerlink" title="selector参数类型与逻辑"></a>selector参数类型与逻辑</h2><h2 id="保持itcast对象是伪数组"><a href="#保持itcast对象是伪数组" class="headerlink" title="保持itcast对象是伪数组"></a>保持itcast对象是伪数组</h2><ul><li>在itcast的原型上添加length=0；表示itcast对象默认的属相为0；</li></ul><h2 id="功能类方法toArray"><a href="#功能类方法toArray" class="headerlink" title="功能类方法toArray"></a>功能类方法toArray</h2><ol><li></li><li><p>功能：将itcast对象，转换成真数组</p></li><li><p>实现思路：借调数组的slice方法，</p></li></ol><h2 id="功能类get方法"><a href="#功能类get方法" class="headerlink" title="功能类get方法"></a>功能类get方法</h2><ol><li><p>语法：<code>itcast对象.get( index )</code></p></li><li><p>功能：根据索引获取指定的dom元素</p></li><li><p>实现思路：</p><ul><li>判断index是不是null undefined值，如果是就返回一个数组，存储itcast对象所有的dom元素</li><li>判断index是否小于0，是 就index+this.length转换成自然数索引值，</li><li>返回this[index]</li></ul></li></ol><h2 id="鸭子类型Ducking-Type"><a href="#鸭子类型Ducking-Type" class="headerlink" title="鸭子类型Ducking Type"></a>鸭子类型Ducking Type</h2><ul><li><p>如果一个东西，走路像鸭子，声音像鸭子，那么它就是鸭子。</p></li><li><p>实现伪数组对象，在控制台显示时是以数组形式显示</p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 原生框架封装 </tag>
            
            <tag> 原生js实现jq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jquery框架封装练习01</title>
      <link href="/2016/11/15/%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85%E7%BB%83%E4%B9%A001/"/>
      <url>/2016/11/15/%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85%E7%BB%83%E4%B9%A001/</url>
      <content type="html"><![CDATA[<ul><li><p>我们通过原生的js实现一些jq的功能，通过练习，锻炼我们的分析问题的能力。锻炼编程的思维能力。</p></li><li><p>查询DOM方法</p></li><li>操作DOM方法<ul><li>appendTo</li><li>append</li><li>prependTo</li><li>prepend</li><li>next/prev</li><li>nextAll/prevAll</li><li>before</li><li>after</li><li>parent /parents</li><li>nextSibling</li><li>attr</li><li>prop</li><li>val</li><li>html</li><li>text</li><li>css</li><li>addClass</li><li>hasClass</li><li>removeClass</li><li>toggleClass</li><li>on</li><li>off</li><li>click /dbclick/keydown</li><li>$.ajax</li></ul></li></ul><h2 id="jQuery框架结构"><a href="#jQuery框架结构" class="headerlink" title="jQuery框架结构"></a>jQuery框架结构</h2><ol><li>为了防止对变量和全局对象的污染，使用沙箱模式</li><li>jq的功能是查询DOM和操作DOM，<ul><li>在查询时，通过选择器来查询。因此要使用函数去实现Dom元素的查询。在实现时，要先定义一个函数init，</li><li>查询到DOM后，要对这些DOM进行操作，此时，要使用面向对象编程的方式来实现，创建一个对象，然后通过该对象的方法来实现操作查询到的DOM元素。</li></ul></li><li>由于框架的结构在完成之后，不允许任何使用者随意改动，所以用户如果想要扩展方法，就必须向其能拿到的对象上扩展，$-&gt;createinit，也就是工厂函数以及其原型。最终要实现init对象继承自createinit函数的原型。</li></ol><a id="more"></a><h2 id="jQuery对象的本质"><a href="#jQuery对象的本质" class="headerlink" title="jQuery对象的本质"></a>jQuery对象的本质</h2><pre><code>是一个伪数组对象，在自然数的索引上存储的是查询到的DOM元素，本质是jQuery原型上的init构造函数的实例。</code></pre><h2 id="init构造函数的参数类型"><a href="#init构造函数的参数类型" class="headerlink" title="init构造函数的参数类型"></a>init构造函数的参数类型</h2><ul><li>构造函数中传入参数的类型有很多，所以我们需要对传入的参数进行判断，根据传入参数的不同，实现不同的功能。</li></ul><ol><li><p>string</p><ul><li>html字符串：创建对应的html元素</li><li>选择器：在DOM树上查询元素</li></ul></li><li><p>dom元素</p><ul><li>将其转换成init对象</li></ul></li></ol><ol start="3"><li><p>dom数组和伪数组</p><ul><li>转换成init对象</li></ul></li><li><p>函数</p><ul><li>其实就是入口函数</li><li>监听dom树是否加载完毕，如果加载完毕就执行函数</li></ul></li><li><p>非法值 null undefined</p></li></ol><ul><li>返回空的init对象</li></ul><h2 id="添加类型判断方法"><a href="#添加类型判断方法" class="headerlink" title="添加类型判断方法"></a>添加类型判断方法</h2><ul><li>根据上面的类型需要做出判断，添加对应的怕段方法</li></ul><ol><li><p>isString方法：判断是否为字符串</p></li><li><p>isHTML方法：判断是否为html字符串</p></li><li><p>isDOM方法：判断是否是dom节点</p></li><li><p>isArrayLike方法：判断是否为数组或伪数组对象</p></li><li><p>isFunction方法：判断是否为函数类型</p></li><li><p>isWindow方法：判断是否为window对象</p></li></ol>]]></content>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 原生js实现jq，原生框架封装 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS原型链总结</title>
      <link href="/2016/10/10/js%E5%8E%9F%E5%9E%8B/"/>
      <url>/2016/10/10/js%E5%8E%9F%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="定义：是函数的prototype属性所引用的对象"><a href="#定义：是函数的prototype属性所引用的对象" class="headerlink" title="定义：是函数的prototype属性所引用的对象"></a>定义：是函数的prototype属性所引用的对象</h3><h3 id="目的：为了同类对象之间的数据共享"><a href="#目的：为了同类对象之间的数据共享" class="headerlink" title="目的：为了同类对象之间的数据共享"></a>目的：为了同类对象之间的数据共享</h3><h3 id="实际开发的使用"><a href="#实际开发的使用" class="headerlink" title="实际开发的使用"></a>实际开发的使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 1: 定义构造函数，实现函数体部分</span></span><br><span class="line"><span class="comment">// 使用构造函数 结合原型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 特有的属性写在这里</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2：将该对象相关的方法定义在原型上</span></span><br><span class="line"><span class="comment">// 将共有的属性（一般是方法）</span></span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Person.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line"><span class="keyword">constructor</span>: Person,</span><br><span class="line">say: function() &#123;&#125;,</span><br><span class="line">run: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 3：创建对象</span></span><br><span class="line"><span class="keyword">var</span> zs = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="定义：指一个对象有权去访问另一个对象上的成员"><a href="#定义：指一个对象有权去访问另一个对象上的成员" class="headerlink" title="定义：指一个对象有权去访问另一个对象上的成员"></a>定义：指一个对象有权去访问另一个对象上的成员</h3><h3 id="继承的实现"><a href="#继承的实现" class="headerlink" title="继承的实现"></a>继承的实现</h3><ol><li><p>原型式</p></li><li><p>混入式</p></li><li><p>借用构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"> name, age, sex </span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"> name, age, sex, phoneNo </span>) </span>&#123;</span><br><span class="line">Animal.call( <span class="keyword">this</span>, name, age, sex );</span><br><span class="line"><span class="keyword">this</span>.phoneNo = phoneNo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zs = <span class="keyword">new</span> Person( <span class="string">'张三'</span>, <span class="number">18</span>, <span class="string">'boy'</span>, <span class="string">'13838383838'</span> );</span><br></pre></td></tr></table></figure></li></ol><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="本质是通过-proto-属性连接起来的，体现继承层次关系的。"><a href="#本质是通过-proto-属性连接起来的，体现继承层次关系的。" class="headerlink" title="本质是通过__proto__属性连接起来的，体现继承层次关系的。"></a>本质是通过__proto__属性连接起来的，体现继承层次关系的。</h3><h3 id="掌握程度"><a href="#掌握程度" class="headerlink" title="掌握程度"></a>掌握程度</h3><ol><li><p>给定一个对象，可以迅速找到该对象的原型链</p></li><li><p>找到该对象的三口之家</p></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数是js的一等公民"><a href="#函数是js的一等公民" class="headerlink" title="函数是js的一等公民"></a>函数是js的一等公民</h3><ol><li><p>函数有双重身份</p><ul><li>对象-可以添加属性和方法–静态成员</li><li>函数-在调用时，就存在四种调用模式；递归调用</li></ul></li><li><p>可以嵌套使用</p><ul><li>js使用词法作用域，那么会产生作用域链</li></ul></li><li><p>可以作为其他函数的实参</p><ul><li>回调函数</li></ul></li><li><p>可以作为其他函数的返回值</p><ul><li>闭包</li></ul></li><li><p>可以限定作用域</p></li><li><p>可以作为对象的属性值<br><code>`</code></p></li></ol><tag>哈哈哈哈</tag>]]></content>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 原型 </tag>
            
            <tag> 原型链 </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>canvas入门2</title>
      <link href="/2016/09/11/canvas%E5%85%A5%E9%97%A82/"/>
      <url>/2016/09/11/canvas%E5%85%A5%E9%97%A82/</url>
      <content type="html"><![CDATA[<ul><li>懒加载：现在不加载，用的时候再加载，</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ol><li><p>移动的小球 实线思路：</p><ul><li>简单版</li></ul><ol><li>利用计时器，定时执行</li><li>首先绘制一个圆形，圆从左上角出来，然后定时改变圆心的位置，再进行绘制，</li><li>等到x轴的坐标大于w或者小于0，改变每一步的正负值，使其反向运动，</li></ol><ul><li>鼠标进入再鼠标所在位置绘制圆形，然后开始下落</li></ul></li><li><p>时钟案例</p></li></ol><a id="more"></a><pre><code>- 实现效果   ![cloc](/images/clock.png)- 实现思路1.  ​绘制表盘</code></pre><h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>]]></content>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 画布 </tag>
            
            <tag> Canvas </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Canvas入门1</title>
      <link href="/2016/09/10/canvas%E5%85%A5%E9%97%A81/"/>
      <url>/2016/09/10/canvas%E5%85%A5%E9%97%A81/</url>
      <content type="html"><![CDATA[<ol><li><p>概念：中文：“画布，帆布”<br>HTML5提出一个新的标签。可以通过脚本语言（JS）在其上面绘制图形、图像以及制作动画。</p></li><li><p>基本使用</p></li></ol><ul><li>创建Canvas标签，同时指定canvas标签的大小；如果不指定的话，默认值为 300 * 150 （px）<br> 如果想动态改变canvas的宽和高，必须通过其属性节点width以及height来改变，不能通过css样式来改变。</li><li>通过js获取到canvas对象。本身Canvas不具备绘图能力。</li><li>通过Canvas对象调用getContext方法来获取绘图的API方法</li><li>使用获取到绘图工具来绘制图形</li></ul><ol start="3"><li>getContext方法</li></ol><ul><li>语法: &lt;canvas对象&gt;.getContext(‘2d|WebGL’);</li><li>功能：获取绘制平面图形或立体图形的api方法以及相关属性；如果参数值为’2d’<br> ，表示获取绘制平面图形的工具；如果参数值为’WebGL’,表示获取绘制立体图形的工具。</li></ul><ol start="4"><li>基本绘图API</li></ol><ul><li>ctx.moveTo(x, y) 移动笔触到指定点。</li><li>ctx.lineTo(x, y) 从笔触所在点连线到指定点</li><li>ctx.stroke(); 将当前路径绘制的图形描绘其边框</li><li>ctx.fill(); 填充一个封闭的图形（将当前路径形成一个封闭图形，然后在填充。）</li><li>stroke方法与fill方法可以同时调用</li></ul><a id="more"></a><ol start="5"><li>开启新路径的方法</li></ol><ul><li>ctx.beginPath();</li></ul><ol start="6"><li>闭合路径的方法</li></ol><ul><li>ctx.closePath();<br>如果当前路径，没有形成一个封闭的图形，可以调用该方法来将图形闭合。</li><li>注意：beginPath与closePath不需要成对出现</li></ul><ol start="7"><li><p>非零环绕原则：是用来判断某一封闭的区域是否要填充。<br>如果想判断指定区域是否填充，就在该区域内选择任意点，然后从该点引出一条射线，穿过整个图形到外部。查看该射线与图形的相交线，如果相交线是顺时针穿出射线，计数 + 1；如果是逆时针穿出射线，计数 -1；如果最后所有计数累加在一起，值不为0就填充该区域;</p><p>如果相交线是自上而下的穿出射线，即为顺时针穿出，计数 +1<br>如果相交线是自下而上的穿出射线，即为逆时针穿出，计数 -1</p></li><li><p>奇偶原则：是用来判断某一封闭的区域是否要填充<br>如果想判断指定区域是否填充，就在该区域内选择任意点，然后从该点引出一条射线，穿过整个图形到外部。查看该射线与图形的相交线的个数。如果为奇数，那么就填充；如果为偶数就不填充。</p></li></ol><h3 id="线性相关属性"><a href="#线性相关属性" class="headerlink" title="线性相关属性"></a>线性相关属性</h3><ol><li>设置线宽</li></ol><ul><li>ctx.lineWidth = value;</li></ul>]]></content>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> canvas </tag>
            
            <tag> 画布 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于js中的静态方法和实例方法</title>
      <link href="/2016/08/15/%E5%85%B3%E4%BA%8Ejs%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/"/>
      <url>/2016/08/15/%E5%85%B3%E4%BA%8Ejs%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<ul><li><p>最近有人问我关于什么静态方法和实例方法不是太清除，所以做一个整理。</p></li><li><p>什么是静态方法：</p><blockquote><p>   静态方法是指不需要声明类的实例就可以使用的方法。</p></blockquote></li></ul><p>代码演示<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">//在foo上直接添加静态方法</span></span><br><span class="line">foo.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是静态方法，不需要实例化，可以直接用函数调用!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">foo.say();<span class="comment">//函数直接调用方法say，打印hello</span></span><br></pre></td></tr></table></figure></p><ul><li>什么是实例方法<blockquote><p>   实例方法是指必须要先使用”new”关键字声明一个类的实例, 然后才可以通过此实例访问的方法。</p></blockquote></li></ul><a id="more"></a><p>代码演示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是实例化之后才可以调用的方法！"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Fn();<span class="comment">//需要首先实例化</span></span><br><span class="line">obj.say();<span class="comment">//才可以调用</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
            <tag> js </tag>
            
            <tag> 静态方法 </tag>
            
            <tag> 实例方法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AngularJS系列之模块化介绍</title>
      <link href="/2016/07/20/AngularJS%E7%B3%BB%E5%88%97%E4%B9%8B%E6%A8%A1%E5%9D%97%E5%8C%96%E4%BB%8B%E7%BB%8D/"/>
      <url>/2016/07/20/AngularJS%E7%B3%BB%E5%88%97%E4%B9%8B%E6%A8%A1%E5%9D%97%E5%8C%96%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h2 id="模块化介绍"><a href="#模块化介绍" class="headerlink" title="模块化介绍"></a>模块化介绍</h2><ul><li>通过AngularJS构建应用时，是以模块化的方式组织的，即将整个应用划分成若干个模块，每个模块都各有其职责，最终组合成一个整体。</li><li>采用模块化的组织方式，可以最大程度的实现代码的复用，可以像搭积木一样进行开发。</li></ul><h2 id="定义应用"><a href="#定义应用" class="headerlink" title="定义应用"></a>定义应用</h2><ul><li><p>通过为任一HTML标签添加ng-app属性，可以指定一个应用，表示此标签所包裹的内容都属于应用的一部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--为html标签添加ng-app表明整个文档都是应用--&gt;</span><br><span class="line">&lt;!--ng-app属性可以不赋值，但是要关联相应模块时则必须赋值--&gt;</span><br><span class="line">&lt;html lang=&quot;zh-CN&quot; ng-app=&quot;App&quot;&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="定义模块"><a href="#定义模块" class="headerlink" title="定义模块"></a>定义模块</h2><ul><li><p>AngularJS提供了一个全局对象angular，在此全局对象下存在若干方法，其中angular.module()方法用来定义一个模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过module方法定义模块</span></span><br><span class="line"><span class="comment">//需要传递两个参数，第一个表示模块的名字，</span></span><br><span class="line"><span class="comment">// 第二个表示此模块依赖的其它模块</span></span><br><span class="line"><span class="keyword">var</span> app = angular.module(<span class="string">"app"</span>,[]);</span><br></pre></td></tr></table></figure><p>注：应用本质也是一个模块（一个比较大的模块）；</p></li></ul><h2 id="定义控制器"><a href="#定义控制器" class="headerlink" title="定义控制器"></a>定义控制器</h2><a id="more"></a><ul><li><p>控制器（Controller）作为连接模型（model）和视图（view）的桥梁存在，所以当我们定义好了控制器以后，也就定义好了模型和视图。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app是一个模型实例对象</span></span><br><span class="line"><span class="comment">//通过这个实例对象定义控制器，需要两个参数</span></span><br><span class="line"><span class="comment">//第一个参数表示控制器名称，</span></span><br><span class="line"><span class="comment">//第二个参数是一个数组，这个数组除最后一个单元是函数外，其余都是字符串，标明此控制器的依赖关系</span></span><br><span class="line">app.controller(<span class="string">'studentController'</span>,[<span class="string">'$scope'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//模型（model）</span></span><br><span class="line">  $scope = [</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">"李白"</span>, <span class="attr">sex</span>: <span class="string">'男'</span>, <span class="attr">age</span>: <span class="string">"23"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'华仔'</span>, <span class="attr">sex</span>: <span class="string">'男'</span>, <span class="attr">age</span>: <span class="string">'34'</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>模型数据时要展示到视图上的，所以需要将控制器关联到视图上，通过为HTML标签添加ng-controller属性并赋值相应的控制器的名称，就确立了关联关系，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加ng-controller属性，并赋值为相应的控制器名称--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">table</span> <span class="attr">ng-controller</span>=<span class="string">"StudentController"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">tr</span> <span class="attr">ng-repeat</span>=<span class="string">"student in students"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;student.name&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;student.sex&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;student.age&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>以上为AngularJS最基本的MVC工作模式。</p></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>AngularJS系列之简单介绍</title>
      <link href="/2016/07/11/AngularJS%E4%BB%8B%E7%BB%8D/"/>
      <url>/2016/07/11/AngularJS%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>AngularJS是Google公司开发维护的MVC前端框架；客服了HTMl在构建应用上的不足，降低了开发成本。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>jQuery更准确的说只是一个类库（类库指的是一系列函数的集合）以DOM作为驱动（核心），而AngularJS则是一个框架（诸多类库的集合）以数据和逻辑作为驱动（核心）。</li><li>框架对开发流程和模式做了约束，开发者遵照约束进行开发，更注重的实际的业务逻辑。</li><li>AngularJS有诸多特性，最为核心的就是：模块化，双向数据绑定，语义化标签，依赖注入等。</li><li>类似的框架的还有 BackBone，KnockoutJS，vue，Rect等，</li></ul><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><a id="more"></a><ul><li>MVC是一种开发模式，有模型（Model），视图（View），控制器（Controller），三部分组成，采用这种开发模式为合理组织代码提供了方便，降低了代码间的耦合度，功能结构清晰可见。</li></ul><ol><li>模型（Model）：一般用来处理数据（读取/设置），具体指操作数据库，</li><li>视图（View）：一般用来展示数据，比如通过HTML展示，</li><li>控制器（Controller）：一般用作连接模型和属兔的桥梁。</li></ol><ul><li>MVC被引入到前端开发中，由于受到技术的限制，便有了 一些细节的调整，于是出现了MVC的衍生版（子集）如：MVVM，MVW，MVP，MV*等；</li></ul>]]></content>
      
      
        <tags>
            
            <tag> Angular </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git应用之git基本工作流程</title>
      <link href="/2016/06/13/git%E5%BA%94%E7%94%A8%E4%B9%8Bgit%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2016/06/13/git%E5%BA%94%E7%94%A8%E4%B9%8Bgit%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="初始化本地仓库"><a href="#初始化本地仓库" class="headerlink" title="初始化本地仓库"></a>初始化本地仓库</h2><ul><li><p>git init</p></li><li><p>如果我们想让git去管理某个目录下的文件，首先需要在该目录下初始化仓库。</p></li></ul><h2 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h2><ul><li><p>学习git之前，我们需要首先了解git管理的3种状态，分别是<strong>已提交</strong>，<strong>已修改</strong>，<strong>已暂存</strong>。</p></li><li><p>这三种状态分别对应三种目录空间，</p></li></ul><ul><li>已修改 -&gt;  工作目录</li><li>已暂存 -&gt;    本地仓库暂存区 通常存放在git目录中的HEAD或INDEX文件中</li><li>已提交 -&gt;  本地仓库的版本库</li></ul><h2 id="git基本工作流程"><a href="#git基本工作流程" class="headerlink" title="git基本工作流程"></a>git基本工作流程</h2><a id="more"></a><ul><li>git的工作流程大概分成三个步骤：</li></ul><ol><li><p>在工作区域修改文件。</p></li><li><p>将工作目录的文件提交到暂存区域，</p></li><li><p>最后再将暂存区文件提交的本地版本库，形成一个版本保存起来</p></li></ol><ul><li>每一次从暂存区提交到版本库，都会形成一个新的版本库。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 版本控制 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git应用之版本控制工具</title>
      <link href="/2016/05/20/git%E5%BA%94%E7%94%A8%E4%B9%8B%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
      <url>/2016/05/20/git%E5%BA%94%E7%94%A8%E4%B9%8B%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<h2 id="版本控制工具"><a href="#版本控制工具" class="headerlink" title="版本控制工具"></a>版本控制工具</h2><h4 id="版本控制工具可以解决的问题"><a href="#版本控制工具可以解决的问题" class="headerlink" title="版本控制工具可以解决的问题"></a>版本控制工具可以解决的问题</h4><ol><li><p>代码合并</p></li><li><p>协同开发</p></li><li><p>提供效率</p></li><li><p>回退版本</p></li><li><p>数据丢失</p></li><li><p>分支管理-多任务处理</p></li></ol><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ol><li><p>集中式版本控制管理工具：</p><ul><li><p>如：svn</p></li><li><p>在集中式版本控制工具中，都会有一个中央服务器，所有的协同开发者都需要来连接到这个服务器，将所有源代码都放在中央服务器上，</p></li><li><p>开发中，首先需要从中央服务器种下载代码（或者更新代码），然后在本地开发，</p></li><li><p>如果开发完毕，需要通过网络把开发完成的代码提交到中央服务器上。</p></li><li><p>这种方式解决了多人协同开发的问题，由于过渡依赖于网络和中央服务器，</p></li><li><p>如果中央服务器出现故障，将会严重导致数据版本丢失的风险，</p></li><li><p>另外，如果网路出现问题，也就没有办法更新，同步代码。</p><a id="more"></a></li></ul></li></ol><ol start="2"><li><p>分布式</p><ul><li><p>这种方式不需要中央服务器，每一个协同开发者，都是有一个完整的版本库，这样一来，任何协同开发者出现问题，事后都可以通过其它协同开发者进行恢复。</p></li><li><p>由于版本库在本地计算机，也就不再受网络影响，如果要将本地修改的代码推送给其它协同开发者，还需要一台 共享服务器，所有开发者通过这台服务器进行同步和更新。</p></li><li><p>分布式版本控制系统弥补了集中式版本控制工具的缺陷，成为了版本控制的首选，现在用的最多的就是Git。</p></li></ul></li></ol>]]></content>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 版本控制 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git应用之git和github</title>
      <link href="/2016/05/15/git%E5%BA%94%E7%94%A8%E4%B9%8Bgit%E5%92%8Cgithub/"/>
      <url>/2016/05/15/git%E5%BA%94%E7%94%A8%E4%B9%8Bgit%E5%92%8Cgithub/</url>
      <content type="html"><![CDATA[<h2 id="git和github的区别"><a href="#git和github的区别" class="headerlink" title="git和github的区别"></a>git和github的区别</h2><ul><li><p>git是一个软件，是一种版本控制工具，通过git命令提供的指令，方便管理源码，在实际开发时，可以将更多的经理集中在开发上，而不是要分出精力去管理代码的合并和版本控制问题。</p></li><li><p>github是一个网站，提供远程仓库，方便开发人员的交流学习。</p></li><li>github可以为git提供一些服务，比如 远程共享仓库，以及开发人员的交流平台。</li></ul><h2 id="配置SSH免密码下载"><a href="#配置SSH免密码下载" class="headerlink" title="配置SSH免密码下载"></a>配置SSH免密码下载</h2><ul><li>ssh-keygen -t rsa</li></ul><h2 id="git指令"><a href="#git指令" class="headerlink" title="git指令"></a>git指令</h2><ol><li><p>从远程服务器上获取指定仓库的分支，并且与工作目录的分支进行合并操作，如果出现问题，需要手动解决就好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull [remote url] branchName</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol start="2"><li><p>如果本地开发完成，要将本地仓库的版本提交到远程仓库，实现共享与项目合并，此时就是用这个指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [remote url] branchName</span><br></pre></td></tr></table></figure></li><li><p>获取远程仓库，但是不合并本地仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch [remote url] branchName</span><br></pre></td></tr></table></figure></li><li><p>把远程仓库的地址存在变量name中，方便以后拉取远程仓库文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add name remoteURL</span><br></pre></td></tr></table></figure><ul><li>如果是拉取远程仓库中的子分支上的文件时，需要在本地首先创建一个同名的子分支 ，否则会把远程仓库子分支中的文件拉取到本地主分支上</li></ul></li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>git应用之vi编辑器</title>
      <link href="/2016/05/14/git%E5%BA%94%E7%94%A8%E4%B9%8Bvi%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>/2016/05/14/git%E5%BA%94%E7%94%A8%E4%B9%8Bvi%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      <content type="html"><![CDATA[<h2 id="认识vi"><a href="#认识vi" class="headerlink" title="认识vi"></a>认识vi</h2><ul><li><p>vi编辑器是Linux下的标配，通过它我们可以创建，编辑文件，它是一个系统自带的文本编辑器，</p></li><li><p>在bash命令行输入 vi 文件名，即可打开文件，进入vi编辑模式。</p><h2 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h2></li><li><p>vi编辑器提供了3种模式，分别是命令模式,插入模式，末行模式，每种模式下用户所能进行的操作是不一样的。</p></li><li><p>3种模式的切换如下图：</p><p>  <img src="/images/vi.png" alt="vi3种模式的切换"></p></li><li><p>通过上图我们发现，输入模式是不能直接切换到末行模式的，必须要先切换到命令模式。</p></li></ul><h2 id="VI编辑器快捷键"><a href="#VI编辑器快捷键" class="headerlink" title="VI编辑器快捷键"></a>VI编辑器快捷键</h2><h4 id="末行模式："><a href="#末行模式：" class="headerlink" title="末行模式："></a>末行模式：</h4><a id="more"></a><ol><li><p>:w(小写) 保存；</p></li><li><p>:w filename    另存为；</p></li><li><p>:q    退出</p></li><li><p>:wq    保存并退出</p></li><li><p>:e!    撤销更改</p></li><li><p>:q!    不保存强制退出</p></li><li><p>:set nu    设置行号</p></li></ol><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><ol><li><p>ZZ(大写)    保存并退出</p></li><li><p>u    撤销操作，可多次使用</p></li><li><p>dd    删除当前行</p></li><li><p>yy    复制当前行</p></li><li><p>p    粘贴内容</p></li><li><p>ctrl+f    向前翻页</p></li><li><p>ctrl+b    向后翻页</p></li><li><p>i    进入编辑模式，在当前光标插入</p></li><li><p>a    进入编辑模式，在当前光标后插入</p></li><li><p>A    进入编辑模式，光标移动到行尾</p></li><li><p>o    进入编辑模式，当前行下面插入新一行</p></li><li><p>O    进入编辑模式，当前行上面插入一行</p></li></ol><h4 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h4><ul><li>编辑模式下，操作和正常widows编辑器操作类似</li></ul>]]></content>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> vi </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AJAX应用之基本功</title>
      <link href="/2016/05/13/AJAX%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8A%9F/"/>
      <url>/2016/05/13/AJAX%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8A%9F/</url>
      <content type="html"><![CDATA[<h1 id="静态资源和动态资源"><a href="#静态资源和动态资源" class="headerlink" title="静态资源和动态资源"></a>静态资源和动态资源</h1><blockquote><p>我们把开发好的html css js部署到服务器上，然后就可以访问了，我们称这些服务器上的文件为资源。</p></blockquote><h2 id="我们把资源分为两类："><a href="#我们把资源分为两类：" class="headerlink" title="我们把资源分为两类："></a>我们把资源分为两类：</h2><blockquote><p>实际上，我们开发都是在开发资源，开发好了部署到服务器上，然后客户端就可访问我的资源了。</p></blockquote><ul><li><p>资源分为两类</p><ol><li>静态资源</li></ol></li></ul><blockquote><p>   可以通过浏览器直接打开，直接解析的我们称为静态资源。html,js,css.inage 我们可以理解为静态资源</p></blockquote><ol start="2"><li>动态资源</li></ol><blockquote><p>   php，jsp，asp 我们可以理解为动态资源</p></blockquote><h2 id="动态资源和静态资源的区别"><a href="#动态资源和静态资源的区别" class="headerlink" title="动态资源和静态资源的区别"></a>动态资源和静态资源的区别</h2><ul><li><p>浏览器只认识静态资源。</p></li><li><p>我的浏览器通过输入地址区访问呢服务器，实际上是去访问服务器上的资源。</p></li></ul><a id="more"></a><ul><li>服务器上有静态资源，也有动态资源。</li><li>如果我的浏览器访问的是服务器上的动态资源，服务器会把动态资源转换称静态资源，然后在传给客户端浏览器。</li><li>如果我的浏览器访问的是服务器上的静态资源，那么服务器会直接把静态资源传送给浏览器解析。</li><li>动态资源是在服务端运行的，静态资源是在客户端运行的。</li></ul><ul><li>php 就是在服务端运行的，用来处理服务端逻辑的。</li></ul><h1 id="客户端与服务端进行交互"><a href="#客户端与服务端进行交互" class="headerlink" title="客户端与服务端进行交互"></a>客户端与服务端进行交互</h1><h2 id="客户端发送请求有几种方式："><a href="#客户端发送请求有几种方式：" class="headerlink" title="客户端发送请求有几种方式："></a>客户端发送请求有几种方式：</h2><ol><li><p>在地址栏输入地址发送请求</p></li><li><p>点击一个超链接，发送请求</p></li><li><p>表单提交也是属于发送请求</p></li></ol><ul><li>发送请求是给服务器端进行提交，提交数据到服务器</li><li>提交有两种常见的方式，一个是get，一个是post</li></ul><h2 id="1-什么是get提交"><a href="#1-什么是get提交" class="headerlink" title="1. 什么是get提交"></a>1. 什么是get提交</h2><blockquote><p>   在地址栏输入地址发送请求，点击超链接也属于get提交<br> 表单提交，<code>&lt;form action=&quot;&quot; method=&quot;get&quot;&gt;&lt;/form&gt;</code>默认是get方式提交。<br> ?paraName=value&amp;paraName=value&amp;paraName=value</p></blockquote><h2 id="2-什么是post提交呢？"><a href="#2-什么是post提交呢？" class="headerlink" title="2. 什么是post提交呢？"></a>2. 什么是post提交呢？</h2><blockquote><p>   表单提交，可以设置称post方式提交， 会自动把数据发送到服务器</p></blockquote><h2 id="3-服务端"><a href="#3-服务端" class="headerlink" title="3.  服务端"></a>3.  服务端</h2><ol><li>接收请求<br>$_GET $POST这两个变量得到的值是一个关联数组，<br>客户端的数据放在关联数组里面，需要根据key去获取里边的值</li><li>处理请求<br>连接数据库，增删改查</li><li>响应数据<br>echo根据处理请求的逻辑，给客户端不同的响应结果</li></ol><h2 id="服务端接收到客户端的请求，一般要做那些处理？"><a href="#服务端接收到客户端的请求，一般要做那些处理？" class="headerlink" title="服务端接收到客户端的请求，一般要做那些处理？"></a>服务端接收到客户端的请求，一般要做那些处理？</h2><h4 id="1-用户登录"><a href="#1-用户登录" class="headerlink" title="1.用户登录"></a>1.用户登录</h4><ol><li>接收请求，接收用户名以及密码</li><li>对接收到的用户名密码进行判断，<ul><li>如果正确，则进行连接数据</li><li>如果不正确就提示错误</li></ul></li></ol><h4 id="2-文件上传"><a href="#2-文件上传" class="headerlink" title="2.文件上传"></a>2.文件上传</h4><ul><li><p>客户端：</p><ol><li>必须是表单提交的</li><li>表单提交里面必须有一个 input type=“file”</li><li>必须是post方式提交的</li><li>必须给表单设置一个属性，<code>enctype=&quot;multipart/form-data</code></li></ol></li><li><p>服务端（php）</p><ol><li>要接收客户端的数据， $_GET, $_POST ,不能接收文件上传的数据，文件上传的数据，我们应该用$_FILES 的变量去接收，接收的数据也是一个关联数组</li><li>接收到这个数据之后，需要把这些数据保存到服务端硬盘上面。</li></ol></li></ul>]]></content>
      
      
        <tags>
            
            <tag> ajax </tag>
            
            <tag> 基本功 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git应用之git常用操作</title>
      <link href="/2016/05/13/git%E5%BA%94%E7%94%A8%E4%B9%8Bgit%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2016/05/13/git%E5%BA%94%E7%94%A8%E4%B9%8Bgit%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<ul><li>这篇主要介绍的是如何配置git和相关操作命令，方便交流学习和以后查阅。</li></ul><h2 id="1-配置用户"><a href="#1-配置用户" class="headerlink" title="1.    配置用户"></a>1.    配置用户</h2><ul><li><p>git安装完成之后，我们需要配置个人信息，配置方式如下。</p></li><li><p>git config [option] </p><ul><li>–global 全局配置，当前用户下的所有仓库都共享同一个用户的配置信息</li><li>–system 系统配置，该电脑下的所有仓库都共享一个用户的配置信息</li><li>–local     本地配置，该仓库下使用当前配置的用户信息。</li></ul></li><li>配置用户名：git config –global user.name  “wangpansheng”</li><li>配置邮箱：    git config –global user.email  “<a href="mailto:wps@qq.com" target="_blank" rel="noopener">wps@qq.com</a>“</li><li>获取信息：    git config –get user.name || –get user.email</li><li>配置信息存放在用户文件夹中的.gitconfig中存放着。</li><li>可以通过重复配置信息，覆盖之前配置的信息</li></ul><h2 id="2-仓库初始化"><a href="#2-仓库初始化" class="headerlink" title="2.    仓库初始化"></a>2.    仓库初始化</h2><ul><li><p>使用git管理代码之前需要首先在工作目录下，输入该命令，初始化一个仓库。</p></li><li><p>git init</p></li></ul><h2 id="3-查看文件状态"><a href="#3-查看文件状态" class="headerlink" title="3.    查看文件状态"></a>3.    查看文件状态</h2><ul><li>查看当前工作目录文件的状态，</li><li>如果下边文件名是红色的就是没有被追踪的，或者是暂存之后又被修改的文件。</li><li>如果绿色的就是已经add暂存了的文件。</li><li><p>会忽略空文件夹</p></li><li><p>medified 表示是跟踪到修改的文件</p></li><li><p>git status</p></li></ul><a id="more"></a><h2 id="4-添加到暂存区"><a href="#4-添加到暂存区" class="headerlink" title="4.    添加到暂存区"></a>4.    添加到暂存区</h2><ul><li><p>如果要把本地工作目录的文件添加到暂存区，也就是想要让git追踪文件的变化，就需要使用git add命令。然后使用git status查看文件状态是否被追踪。</p></li><li><p>git add [option]</p></li><li><p>*| -A    暂存所有文件</p></li><li>文件名，暂存指定文件</li></ul><h2 id="5-撤销更改"><a href="#5-撤销更改" class="headerlink" title="5.    撤销更改"></a>5.    撤销更改</h2><ul><li>有时候，我们可能会想要把代码恢复到以前的版本，这是就需要用到checkout了。</li><li>在撤销更该的时候，如果暂存区有备份，就恢复暂存区文件到工作目录，</li><li><p>如果暂存区没有就去版本库去恢复。</p></li><li><p>git checkout filename</p></li></ul><h2 id="6-提交"><a href="#6-提交" class="headerlink" title="6.    提交"></a>6.    提交</h2><ul><li><p>git commit [option] -m “当前版本备注信息”</p></li><li><p>提交单个文件时，option输入文件名即可，</p></li><li><p>在做版本回退时，需要根据版本备注信息选择回退的版本。</p></li><li><p>没提交一次都会有一个版本号，一般称为SHA值，</p></li></ul><h2 id="7-查看提交日志"><a href="#7-查看提交日志" class="headerlink" title="7.    查看提交日志"></a>7.    查看提交日志</h2><ul><li><p>有时候我们需要查看提交的历史纪录，可以通过git log查看提交的历史记录</p></li><li><p>git log            不包含回退之后的版本</p></li><li>git log –oneline    简略显示日志</li><li>git reflog    查看所有历史版本，</li></ul><h2 id="8-恢复之前提交的状态"><a href="#8-恢复之前提交的状态" class="headerlink" title="8.    恢复之前提交的状态"></a>8.    恢复之前提交的状态</h2><ul><li><p>回退到指定的版本</p></li><li><p>git reset [option] 版本id</p></li><li><p>将指定版本内的文件替换掉工作目录内的文件，实现版本回退，</p></li><li><p>如果传了 –hard 会同时更改暂存区文件</p></li><li><p>git reset HEAD^ 回退到前一次提交的版本，</p></li><li><p>git reset HEAD^^|| HEAD~2回退到前两次的版本</p></li><li><p>reset命令有3中方式：</p><ul><li>git reset  –mixed    <ul><li>默认方式，不带任何参数的git reset，</li><li>版本区和暂存区变化，工作区不变化</li></ul></li><li>git reset –soft    <ul><li>回退到某个版本，只回退了commit的信息，不会恢复暂存区，</li><li>如果还要提交，直接commit即可</li></ul></li><li>git reset –hard<ul><li>彻底回退到某个版本，本地的源码也会变为上一个版本的内容。</li></ul></li></ul></li></ul><h2 id="9-git分支"><a href="#9-git分支" class="headerlink" title="9.    git分支"></a>9.    git分支</h2><ul><li><p>在初始化一个本地仓库时，默认是没有主分支的，必须至少提交一次版本之后，git才会创建master主分支。</p></li><li><p>git在创建分支时，必须保证有master主分支。</p></li></ul><ol><li><p>创建分支</p><ul><li><p>git branch name    创建分支</p></li><li><p>git checkout -b branchName  创建分支并切换到该分支</p></li></ul></li><li><p>查看分支</p><ul><li>git branch</li></ul><ul><li>有星号*标记的分支，就是当前工作目录所在的分支，</li></ul></li><li><p>切换分支</p><ul><li><p>git checkout branchName</p></li><li><p>切换到指定分支</p></li></ul></li><li><p>分支的合并</p><ul><li><p>git merge branchName</p></li><li><p>将指定分支合并到当前分支</p></li></ul></li><li><p>删除分支</p><ul><li><p>git branch -d branchName</p></li><li><p>删除指定的分支</p></li></ul></li></ol><h4 id="git分支策略"><a href="#git分支策略" class="headerlink" title="git分支策略"></a>git分支策略</h4><ul><li>在实际开发中，虽然git分支很强大，但是也不是随便用的，通常我们需要按照一定的策略使用分支，提高开发效率。</li></ul><ol><li><p>保证主分支的的稳定性，也就是说要保证主分支的代码，无bug，功能完整，不能在主分支上直接进行开发。</p></li><li><p>如果需要开发新功能时，那么就创建一个该功能的分支，然后在该分支上进行代码编写。当功能开发完毕，并且测试无bug，将该分支上的代码合并到主分支上。</p><ul><li>该分支命名一般规范：所有的开发分支都以”dev-“+相关功能描述的单词。</li><li>eg： 要开发登录功能时， 此时可以考虑创建一个开发分支，名字为dev-login</li></ul></li><li><p>如果开发时遇到协同开发，就要创建协同开发分支，在该分支上去编写代码。</p><ul><li>当代码合并时，可能会出现，代码冲突，一旦出现冲突，git无法解决，需要我们认为手动去处理。</li><li>该分支一般的命名规范为：<ul><li>所有的开发分支都以”feature-“+相关描述词；</li><li>eg：开发主页功能时，可以考虑创建一个分支，名字为feature-index</li></ul></li></ul></li><li><p>如果在开发时，接到一个临时修改的bug的任务时，此时不要在主分支或当前未完成的分支上去修改，此时，创建一个bug分支，在该分支上去修改出现bug的代码，修改完成之后，将其合并到主分支，</p><ul><li>该分支命名规范：</li><li>所有的开发分支都以”bug”+相关描述词；</li><li>eg: 要修改登录超时问题，此时可以考虑创建一个bug分支，名字为bug-loginTimeout</li></ul></li></ol><ul><li>如果出现冲突，必须手动解决冲突，然后重新提交版本，</li></ul>]]></content>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 常用命令操作 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git应用之认识bash</title>
      <link href="/2016/05/13/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E4%B9%8Bbash/"/>
      <url>/2016/05/13/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E4%B9%8Bbash/</url>
      <content type="html"><![CDATA[<h2 id="什么是shell"><a href="#什么是shell" class="headerlink" title="什么是shell"></a>什么是shell</h2><p>Shell俗称壳，是指”提供使用者使用界面”的软件，接收用户命令，然后调用相应的应用程序。</p><h3 id="shell分类"><a href="#shell分类" class="headerlink" title="shell分类"></a>shell分类</h3><h4 id="图形化shell"><a href="#图形化shell" class="headerlink" title="图形化shell"></a>图形化shell</h4><p>通过友好的可视化界面，调用相应应用程序，如windows系类操作系统，类Unix，Linux系统上的图形化应用程序Gnome，Kde等。</p><h4 id="命令行shell"><a href="#命令行shell" class="headerlink" title="命令行shell"></a>命令行shell</h4><p>通过输入特定命令调用相应的应用程序。如window系统的cmd，Windows PowerShell；Linux系统的bash。</p><h3 id="认识bash"><a href="#认识bash" class="headerlink" title="认识bash"></a>认识bash</h3><ul><li><p>在window下使用bash，需要一个软件，这个软件模拟集成了bash大部分命令，</p></li><li><p>各个shell的功能都差不多，linux默认使用bash，所以主要学习bash。</p></li></ul><h4 id="bash常用命令"><a href="#bash常用命令" class="headerlink" title="bash常用命令"></a>bash常用命令</h4><ul><li><p>pwd(Print Working Directory) 查看当前目录;</p></li><li><p>cd(Change Directory) 切换目录，如cd etc,cd ..返回上一层目录;</p></li><li><p>ls(List) 查看当前目录下内容，如ls-al;</p></li><li>ls -l 以列表形式产看当前目录内容</li></ul><a id="more"></a><ul><li><p>mkdir(Make Directory) 创建目录，可以指定路径创建目录，如mkdir blog;</p></li><li><p>touch    创建文件，</p></li><li><p>cat 查看文件全部内容，cat ./路径/文件名</p></li><li><p>more(unix支持) less(linux支持) 分页查看文件，空格翻页，q退出。</p></li><li><p>rm(remove) 删除文件，如rm 文件名</p></li><li><p>rm -rf 强制删除目录内所有文件，-r(recursion)是递归删除，-f强制删除</p></li><li><p>rmdir(Remove Directory)   删除文件夹，只能删除空文件夹</p></li><li><p>mv(move) 移动文件或重命名,mv index.html ./00/00/index.html</p></li><li><p>cp(copy) 复制文件 </p></li><li><p>head    查看文件前几行，如 head -g index.html</p></li><li><p>tail    查看文件后几行， -n-f,</p></li><li><p>tab    自动补全，连续按两次会将所有匹配内容显示出来</p></li><li><p>history    查看操作历史</p></li><li><p>ssh    远程免密码登录，如ssh <a href="mailto:root@gitlab.study.com" target="_blank" rel="noopener">root@gitlab.study.com</a></p></li><li><blockquote><p>和 &gt;&gt;    重定向，&gt;覆盖，&gt;&gt;追加，如cat index.html &gt; log.txt;</p></blockquote></li><li><p>clear 清空当前窗口</p></li><li><p>curl    网络请求，</p></li><li><p>whoami    查看当前用户</p></li><li><p>以下在winodw集成环境不支持</p></li><li><p>weget    下载</p></li><li><p>tar    解压缩</p></li><li><p>管道符可以将多个命令来连接在一起，上一次命令的执行结果当成下一次命令的参数。</p></li><li>grep    匹配内容，一般结合管道符使用。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> shell </tag>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git应用之认识SSH</title>
      <link href="/2016/05/10/git%E5%BA%94%E7%94%A8%E4%B9%8B%E8%AE%A4%E8%AF%86SSH/"/>
      <url>/2016/05/10/git%E5%BA%94%E7%94%A8%E4%B9%8B%E8%AE%A4%E8%AF%86SSH/</url>
      <content type="html"><![CDATA[<h2 id="什么是SSH"><a href="#什么是SSH" class="headerlink" title="什么是SSH"></a>什么是SSH</h2><ul><li><p>SSH是一种网络协议，用于计算机之间的加密登录。</p></li><li><p>SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。我们主要针对OpenSSH，它是自由软件，应用非常广泛。</p></li><li><p>如果要 在widows种使用SSH，会使用到一种软件PuTTY，我们用的git客户端也集成了SSH。</p></li><li><p>格式：ssh user@host</p></li><li>user 代表用户，host代表要登录的远程计算机</li></ul><h3 id="常见的两种加密方式"><a href="#常见的两种加密方式" class="headerlink" title="常见的两种加密方式"></a>常见的两种加密方式</h3><ul><li><p>常见的两种加密技术，分别是对称性加密和非对称性加密，SSH属于后者。</p></li><li><p>对称性加密算法，在加密和解密时，使用的是同一个密钥；</p></li><li><p>而非对称性加密算法需要两个密钥来进行加密和解密。这两个密钥分别是公开密钥(public key,公钥)和私有密钥(private key,私钥)。</p><a id="more"></a></li></ul><h5 id="非对称性加密的工作原理"><a href="#非对称性加密的工作原理" class="headerlink" title="非对称性加密的工作原理"></a>非对称性加密的工作原理</h5><ul><li>公钥和私钥是成对出现，可以通过ssh-keygen -t rsa来创建，既可以通过密钥加密数据，也可以过通过私钥来加密数据，如果是以公钥进行的数据加密，只有通过与之对应的私钥才可解密，相反，如果以私钥进行的数据加密，则只能通过与之对应的公钥才可将数据解密，这样就可以提高信息传递的安全性，</li></ul><h5 id="免密码登录"><a href="#免密码登录" class="headerlink" title="免密码登录"></a>免密码登录</h5><ul><li>我们可以将本地机器上的公钥保存到特定的远程计算机上，这样当我们再次登录访问这台远程计算机时就可以实现免密码登录了。</li></ul><ol><li><p>ssh-keygen -t rsa 会创建公钥和密钥（默认在用户目录/.ssh中）</p></li><li><p>ssh-copy-id user@host    添加到对应远程主机的用户目录/.ssh目录下</p></li><li><p>也可以登录远程主机，进入到用户目录/.ssh目录下手动创建authorized keys文件，并将自己的公钥粘贴到该文件。</p></li></ol>]]></content>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 工具 </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>什么是ajax</title>
      <link href="/2016/04/24/ajax%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2016/04/24/ajax%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      <content type="html"><![CDATA[<blockquote><p> 什么是ajax</p></blockquote><h2 id="1-同步交互"><a href="#1-同步交互" class="headerlink" title="1. 同步交互"></a>1. 同步交互</h2><p>   客户端请求服务器，服务器接收到请求，处理请求，然后给客户端一个响应，<br>响应的数据会把原来的页面给覆盖。我们把这种交互成为同步交互.</p><h2 id="2-异步交互"><a href="#2-异步交互" class="headerlink" title="2.  异步交互"></a>2.  异步交互</h2><pre><code>客户端请求服务器,服务器接收到请求，处理请求，然后给客户端一个响应，</code></pre><p>响应的数据不会把原来的页面给覆盖。我们把这种交互成为异步交互.</p><p><strong>异步交互实际上就是页面不刷新，就可以动态的去获取服务端的数据</strong></p><p>它是怎么做到的，为什么能够去获取到服务端的数据，它的原理是什么.<br>通过XMLHttpRequest 对象去发送http 请求.</p><h3 id="XMLHttpRequest-交互的几个步骤"><a href="#XMLHttpRequest-交互的几个步骤" class="headerlink" title="XMLHttpRequest 交互的几个步骤"></a>XMLHttpRequest 交互的几个步骤</h3><ol><li>创建这样的一个对象</li><li>我要跟服务端建立一个连接</li><li>我要在连接上面发送数据</li><li>接收服务端返回的数据</li></ol><p>页面不刷新，就完成了跟服务器端的数据交互.</p><h4 id="我假设以后我们做登录是同步交互，还是做异步交互"><a href="#我假设以后我们做登录是同步交互，还是做异步交互" class="headerlink" title="我假设以后我们做登录是同步交互，还是做异步交互."></a>我假设以后我们做登录是同步交互，还是做异步交互.</h4><form action="login.php"><br>    昵称：<input type="text" name="username" id="username"><br>    <span id="message"></span><br>    <br><br><br>    密码：<input type="password" name="password"><br><br><br>    <input type="submit" value="登录"><br></form><ul><li>如果我是做同步登录</li></ul><p>肯定是服务器得到我的请求，决定给我输出什么样的数据。</p><ul><li>如果是做异步登录</li></ul><a id="more"></a><p>给登录按钮添加点击事件，然后获取到用户名，以及密码<br>然后通过XMLHttpRequest 对象发送请求给服务器，服务器返回数据<br>返回了数据之后，然后接收到数据，<br>我肯定是登陆成功，还是失败，然后由客户端来完成跳转<br>window.location.href=””;</p><h2 id="ajax运行过程"><a href="#ajax运行过程" class="headerlink" title="ajax运行过程"></a>ajax运行过程</h2><p>我们做ajax 开发，客户端发送一个请求给服务器，服务器返回数据。<br>返回了数据之后，我通过js 得到数据，得到了数据之后，我把这个数据渲染到页面上面.</p><h2 id="xml和json"><a href="#xml和json" class="headerlink" title="xml和json"></a>xml和json</h2><p>如果跟服务器进行交互，如果传递的数据格式非常大，非常多的情况下，我们一般给传递是数据规定一个格式.</p><p>这个格式有两种，目前市场上面，一种是xml 的数据格式，还有一种是json 的数据格式.<br>xml 跟这个json 都是数据格式。</p><h4 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h4><blockquote><p>  xml 到底是什么样的数据格式</p></blockquote><p>xml 是 <strong>可扩展的标记语言</strong>，html是<strong>超文本标记语言</strong>，都是由<strong>标记</strong>，<strong>标签</strong>组成，</p><ul><li>xml <ul><li>它里面的标签是自定义的，<person></person></li><li>主要是用来做软件的配置文件，用来做数据的传输，xml 一般自己写解析</li></ul></li><li>xml 里面的标记的语法：<ul><li>第一：第一行必须是文档申明  &lt;?xml version=”1.0” encoding=”utf-8” ?&gt;</li><li>第二：必须有且仅有一个根元素</li><li>第三：标签可以嵌套，不能交叉嵌套   <code>&lt;persons&gt;&lt;person&gt;&lt;/person&gt;&lt;/persons&gt;</code></li></ul></li><li><p>html </p><ul><li>里面的标记 是w3c 指定的需要按照w3c 指定的规范去编写</li><li>主要是用来做界面显示的，浏览器解析.</li></ul></li><li><p>一般每一门语言对xml，以及json 都有解决方案</p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo搭建博客常见问题</title>
      <link href="/2016/04/24/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2016/04/24/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="1-当执行hexo-d时报错-执行以下代码之后-重新提交就可以了"><a href="#1-当执行hexo-d时报错-执行以下代码之后-重新提交就可以了" class="headerlink" title="1.  当执行hexo-d时报错,执行以下代码之后,重新提交就可以了"></a>1.  当执行hexo-d时报错,执行以下代码之后,重新提交就可以了</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf false</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-ENOSPC报错"><a href="#2-ENOSPC报错" class="headerlink" title="2. ENOSPC报错"></a>2. ENOSPC报错</h2><blockquote><p>   在ubuntu系统中，执行hexo时，出现ENOSPC报错,可以运行来修复$ npm dedupe，如果还是不行，尝试以下命令：（亲测可行）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo fs.inotify.max_user_watches = 524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> hexo ubuntu </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ECMAScript发展史</title>
      <link href="/2016/03/18/ECMAScript%E5%8F%91%E5%B1%95%E5%8F%B2/"/>
      <url>/2016/03/18/ECMAScript%E5%8F%91%E5%B1%95%E5%8F%B2/</url>
      <content type="html"><![CDATA[<ul><li>ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMA-262标准的实现和扩展。<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3></li></ul><ol><li>历史</li><li>版本</li><li>方言</li><li>对应版本</li><li>参考文献</li><li>参见</li><li>外部链接<h3 id="1-历史"><a href="#1-历史" class="headerlink" title="1.    历史"></a>1.    历史</h3></li></ol><p>1995年12月，升阳公司与网景公司公司一起引入了JavaScript[1]。1996年3月，网景公司发表了支持JavaScript的网景导航者 2.0。由于JavaScript作为网页的客户端脚本语言非常成功，微软于1996年8月引入了Internet Explorer 3.0，这个软件支持一个“约”与JavaScript相容的JScript[2]。<br>1996年11月，网景公司将JavaScript提交给欧洲计算机制造商协会进行标准化。ECMA-262的第一个版本于1997年6月被Ecma组织采纳。<br>ECMAScript是由ECMA-262标准化的脚本语言的名称。JavaScript和JScript与ECMAScript相容，但包含超出ECMAScript的功能。</p><a id="more"></a><h3 id="3-版本"><a href="#3-版本" class="headerlink" title="3.    版本"></a>3.    版本</h3><ul><li>至今为止有七个ECMA-262版本发表。</li></ul><ul><li>1    |    1997年6月        |    首版            |</li><li>2    |    1998年6月        |    格式修正，以使得其形式与ISO/IEC16262国际标准一致|</li><li>3    |    1999年12月    |    强大的正则表达式，更好的词法作用域链处理，新的控制指令，异常处理，错误定义更加明确，数据输出的格式化及其它改变|</li><li>4    |    放弃            |    由于关于语言的复杂性出现分歧,第4版本被放弃,其中的部分成为了第5版本及Harmony的基础。|</li><li>5    |    2009年12月[4]    |    新增“严格模式（strict mode）”，一个子集用作提供更彻底的错误检查,以避免结构出错。澄清了许多第3版本的模糊规范,and accommodates behaviour of real-world implementations that differed consistently from that specification。增加了部分新功能,如getters及setters,支持JSON以及在物件属性上更完整的反射。|</li><li>6    |    2015年6月        |    多个新的概念和语言特性。ECMAScript Harmony将会以“ECMAScript 6”发布。|</li><li>7    |    2016年6月[9]    |    多个新的概念和语言特性<br>|        |                  |      2004年6月Ecma组织发表了ECMA-357标准，它是ECMAScript的一个扩延，也被称为E4X（ECMAScript for XML）。|</li></ul>]]></content>
      
      
        <tags>
            
            <tag> ECMA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AJAX应用之HTTP</title>
      <link href="/2016/03/14/AJAX%E5%BA%94%E7%94%A8%E4%B9%8BHTTP/"/>
      <url>/2016/03/14/AJAX%E5%BA%94%E7%94%A8%E4%B9%8BHTTP/</url>
      <content type="html"><![CDATA[<h1 id="http-协议。"><a href="#http-协议。" class="headerlink" title="http 协议。"></a>http 协议。</h1><blockquote><p>   协议就是约束，http协议是w3c制定的，用来约束客户端浏览器与web服务器进行通讯的数据格式,http 协议是基于请求，响应的协议。客户端浏览器给服务器发送一个请求，服务器给客户端一个响应</p></blockquote><h2 id="http协议的数据格式分为两部分"><a href="#http协议的数据格式分为两部分" class="headerlink" title="http协议的数据格式分为两部分"></a>http协议的数据格式分为两部分</h2><ul><li>客户端发送到服务器的请求，称为请求的数据格式。</li><li><p>服务器响应给客户端的数据，为响应的数据格式.</p></li><li><p>请求的数据格式，是客户端发送给服务器的，分为四个部分</p><ol><li>请求首行</li><li>请求头</li><li>请求空行</li><li>请求体</li></ol></li></ul><h3 id="1-get请求数据格式"><a href="#1-get请求数据格式" class="headerlink" title="1.    get请求数据格式"></a>1.    get请求数据格式</h3><ul><li><p>请求首行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /day08/code/01http/01get.html HTTP/1.1</span><br><span class="line">[GET 告诉服务器提交方式]</span><br><span class="line">[/day08/code/01http/01get.html 告诉服务器，我要去请求的资源的地址]</span><br><span class="line">[HTTP/1.1 协议的版本] 有两个版本，</span><br><span class="line">1.0</span><br><span class="line">1.1</span><br></pre></td></tr></table></figure></li><li><p>请求头 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Host127.0.0.1【请求头的名称，请求头的值】</span><br><span class="line">Cache-Controlmax-age=0这个做缓存控制的.</span><br><span class="line">Upgrade-Insecure-Requests1   没有用过.</span><br><span class="line">User-AgentMozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36 这个是告诉服务器，我客户端浏览器的版本，操作系统的版本</span><br><span class="line">Accepttext/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8接收，告诉服务器，我客户端可以接收那些数据格式.</span><br><span class="line">Refererhttp://127.0.0.1/day08/code/01http/</span><br><span class="line">Accept-Encodinggzip, deflate, sdch   接收的压缩格式. gzip</span><br><span class="line">Accept-Languagezh-CN,zh;q=0.8接收的语言</span><br><span class="line">If-None-Match&quot;7700000000217a-96-548afe60e947a&quot;</span><br><span class="line">If-Modified-SinceFri, 17 Feb 2017 01:33:19 GMT</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-post-请求的数据格式的介绍"><a href="#2-post-请求的数据格式的介绍" class="headerlink" title="2.    post 请求的数据格式的介绍"></a>2.    post 请求的数据格式的介绍</h3><ul><li>请求首行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /day08/code/01http/02post.php HTTP/1.1</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>请求头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Host: 127.0.0.1</span><br><span class="line">内容长度，指的 请求体的长度</span><br><span class="line">Content-Length: 21</span><br><span class="line">缓存的</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">请求的站点的主域名</span><br><span class="line">Origin: http://127.0.0.1</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">告诉服务器客户端浏览器的版本，操作系统的版本.</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36</span><br><span class="line">//这个是post 提交独有第一个请求头，如果发送到服务器的数据有中文，会吧中文进行编码</span><br><span class="line">在发送给服务器，服务器得到数据会自动解码.</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">//接收的数据格式</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">告诉服务器，请求来自于那个页面</span><br><span class="line">Referer: http://127.0.0.1/day08/code/01http/02post.html</span><br><span class="line">接收压缩格式</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">接收的语言</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8</span><br><span class="line">请求空行 [用来将请求头跟请求体进行一个区分，方便服务器解析数据]</span><br></pre></td></tr></table></figure></li><li><p>请求体[客户端发送到服务器的数据.]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=dasfadsfdafs</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-get-跟post-的区别："><a href="#3-get-跟post-的区别：" class="headerlink" title="3.  get  跟post 的区别："></a>3.  get  跟post 的区别：</h3><ol><li><p>get 提交请求的数据都在地址栏中，相对来不安全。</p></li><li><p>get 请求的数据都请求地址的后面，对请求的数据的大小由限制，限制大概1kb</p></li><li><p>get 没有请求体</p></li><li><p>ost 请求的数据在请求体当中，相对来说安全</p></li><li><p>ost 请求的数据大小没有限制。文件上传，这个必须是post 方式提交</p></li><li><p>ost 提交有一个特殊的请求头:<code>Content-Type:application/x-www-form-urlencoded</code><br>可以对请求的数据包含中文的数据进行编码.</p></li><li><p>get 的请求没有没有请求体，也会少一些请求头，所以它传递到服务端的数据要少一些。性能要高一些。</p></li></ol><h3 id="4-服务器响应给客户端的数据也分为四个部分"><a href="#4-服务器响应给客户端的数据也分为四个部分" class="headerlink" title="4.  服务器响应给客户端的数据也分为四个部分"></a>4.  服务器响应给客户端的数据也分为四个部分</h3><ol><li>响应首行</li><li>响应头</li><li>响应空行</li><li>响应体</li></ol><h4 id="1-响应首行"><a href="#1-响应首行" class="headerlink" title="1. 响应首行"></a>1. 响应首行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">协议的版本</span><br><span class="line">200 状态吗 代表ok</span><br><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure><ul><li>实际上我们开发的过程当中还有很多的状态吗<br>404 代表请求的资源没有找到，以后假设出现404<br>500 代表服务器内部错误<br>405 代表请求的方式不支持,如果我的一个php接收post 方式的数据 $_POST<br>然后你以get 方式去请求，就会出现405<br>304 请求的资源没有发生改变. 这个是用来做缓存用的.<br>当我第一次访问<a href="http://127.0.0.1/day08/code/01http/01get.html" target="_blank" rel="noopener">http://127.0.0.1/day08/code/01http/01get.html</a><br>这个页面，服务器会给我一个响应头.<br>Last-Modified:Fri, 17 Feb 2017 01:33:19 GMT<br>告诉客户端浏览器，这个文件的最后修改时间.</li></ul><p>当我再次去访问<a href="http://127.0.0.1/day08/code/01http/01get.html" target="_blank" rel="noopener">http://127.0.0.1/day08/code/01http/01get.html</a><br>会给服务器协议这样的一个请求头<br>If-Modified-Since:Fri, 17 Feb 2017 01:33:19 GMT<br>这个时候服务器就会给客户端一个304 的状态吗，你请求的这个资源<br><a href="http://127.0.0.1/day08/code/01http/01get.html" target="_blank" rel="noopener">http://127.0.0.1/day08/code/01http/01get.html</a> 没有做任何的修改<br>客户端浏览器得到是304，它就会从本地去读取页面</p><h4 id="2-响应头"><a href="#2-响应头" class="headerlink" title="2.  响应头"></a>2.  响应头</h4><p>告诉客户端服务器端的时间.<br>Date: Fri, 17 Feb 2017 01:35:58 GMT<br>告诉客户端服务器的版本<br>Server: Apache/2.2.21 (Win32) PHP/5.3.10<br>文件的最后修改时间<br>Last-Modified: Fri, 17 Feb 2017 01:33:19 GMT</p><p>ETag: “7700000000217a-96-548afe60e947a”<br>Accept-Ranges: bytes<br>内容的长度<br>Content-Length: 150<br>//内容类型，告诉客户端浏览器，我给你返回的是一个文本，html 格式的文本,<br>客户端浏览器得到这个，就会以html 的方式去解析.<br>Content-Type: text/html;<br>header(“Content-Type:text/html;charset=utf-8”)</p><h4 id="3-响应空行"><a href="#3-响应空行" class="headerlink" title="3.  响应空行"></a>3.  响应空行</h4><h4 id="4-响应体"><a href="#4-响应体" class="headerlink" title="4.  响应体"></a>4.  响应体</h4><p>客户端发送到服务器的时候有一个请求头叫做<br>User-Agent:告诉服务器客户端浏览器的版本，操作系统的版本.</p><h4 id="5-响应的头，Refresh-的响应头"><a href="#5-响应的头，Refresh-的响应头" class="headerlink" title="5.  响应的头，Refresh 的响应头"></a>5.  响应的头，Refresh 的响应头</h4><p>服务器给客户端，如果客户端得到这个响应头，它会自动跳转页面.</p><p>Referer 的头，告诉服务器，请求来自于那个页面.<br>    1:广告流量统计，统计到我的网站在那个网站上面打的广告更加有效果。</p><pre><code>2：防盗链，bs 架构，我们可以看到后台的链接，一个连接对应一个资源。</code></pre><p> 互联网上创业，有些软件做功能，有些软件做内容。<br>     一个连接对应一个资源 ，视频行业，最砸钱，谁有视频的资源。视频的资源<br> 现在都要买版权，都要收费。</p><pre><code>www.kuaibo.com ，进入到快播的一个页面，</code></pre><p> 快播视频播放，我就可以引入优酷上面的一个视频资源。<br>    这个时候会给优酷发送一个请求，就会优酷携带一个请求头<br>    Referer:<a href="http://www.kuaibo.com" target="_blank" rel="noopener">www.kuaibo.com</a><br>    我在优酷的后台我就可以判断，如果你请求的Referer 的值不是来自于优酷自己的站点<br>我让你跳转优酷的首页，看看广告.</p><pre><code>http 协议 里面面试的时候一些重点的东西：        1:get 跟post 的区别        2:请求的数据格式，                特殊的请求头                post 提交有一个特殊的请求头                Content-Type:&quot;application/-w-form-data&quot;        3:响应的数据格式。                你知道哪些常见的状态吗                200                404                405                500                304   请求的资源没有发生任何改变，浏览器从缓存里面去找                302   请求重定向                http://www.tieba.com                这个地址会给我一个302 的状态吗                它还会给以location 的地址                302                Location:http://tieba.baidu.com  //响应头：地址 你在请求开发的过程当成碰到什么乱码问题没有        1：客户端的数据发送到服务器，               1:如果说有中文，我们一般使用post 方式提交                //使用js 对魔兽.exe 进行编码. utf-8                //服务器根据这个去进行解码. 以utf-8 去解码               2:&lt;a href=&quot;adsfadsf.php?fileName=&quot;魔兽.exe&quot;&gt;问价下载 &lt;/a&gt;        2：服务器的数据响应给客户端。              1： 当前文件采用的是什么编码              2:  然后 给客户端一个响应头 Content-Type:text/html;charset=当前文件的编码</code></pre>]]></content>
      
      
        <tags>
            
            <tag> ajax </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>快速搭建hexo个人博客站点</title>
      <link href="/2016/03/10/hexo%E9%85%8D%E7%BD%AE%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AB%99%E7%82%B9/"/>
      <url>/2016/03/10/hexo%E9%85%8D%E7%BD%AE%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AB%99%E7%82%B9/</url>
      <content type="html"><![CDATA[<h2 id="1-首先安装hexo命令行，"><a href="#1-首先安装hexo命令行，" class="headerlink" title="1.  首先安装hexo命令行，"></a>1.  首先安装hexo命令行，</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo-cli -g</span><br><span class="line">//安装之后输入下面命令验证是否安装成功</span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure><h2 id="2-接着我们找一个我们打算把博客放在打文件夹中，打开终端"><a href="#2-接着我们找一个我们打算把博客放在打文件夹中，打开终端" class="headerlink" title="2.  接着我们找一个我们打算把博客放在打文件夹中，打开终端"></a>2.  接着我们找一个我们打算把博客放在打文件夹中，打开终端</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//输入下面命令，会自动部署博客框架</span><br><span class="line">hexo init [blog]</span><br><span class="line">//blog 就是我们防止博客文件的文件夹，可以不写，就会在打开终端打目录下直接创建</span><br><span class="line">//完成之后，进入blog文件夹安装依赖</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="3-本地预览"><a href="#3-本地预览" class="headerlink" title="3.  本地预览"></a>3.  本地预览</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>输入命令之后，看到下面这行提示之后，就可以再浏览器输入地址，预览配置好的页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="4-创建新文章"><a href="#4-创建新文章" class="headerlink" title="4.  创建新文章"></a>4.  创建新文章</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new 文章标题</span><br></pre></td></tr></table></figure><p>输入命令之后，就可以再\hexo\source_posts\路径下看到自己输入名字的md文件，文章标题默认就是创建时候写的。</p><h2 id="5-生成部署"><a href="#5-生成部署" class="headerlink" title="5. 生成部署"></a>5. 生成部署</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>输入命令之后，会生成静态页面，</p><h2 id="6-提交"><a href="#6-提交" class="headerlink" title="6. 提交"></a>6. 提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>输入命令，可以把生成的静态页，提交到自己的github主页上。</p>]]></content>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 个人博客 </tag>
            
            <tag> 技术分享 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>markdown基本语法</title>
      <link href="/2016/01/14/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2016/01/14/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><ul><li>标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 一级标题</span><br><span class="line"></span><br><span class="line">## 二级标题</span><br><span class="line"></span><br><span class="line">### 三级标题</span><br></pre></td></tr></table></figure><p>以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。</p><ul><li>在Markdown当中设置标题，还有第二种方式：<br>通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。</li></ul><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><p>如果你需要引用一小段别处的句子，那么就要用引用的格式。</p></li><li><p>只需要在文本前加入 &gt; 这种尖括号（大于号）即可</p></li></ul><a id="more"></a><h2 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h2><ul><li>插入链接与插入图片的语法很像，区别在一个 !号</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">图片为：![]()&#123;ImgCap&#125;&#123;/ImgCap&#125;</span><br><span class="line"></span><br><span class="line">链接为：[]()</span><br></pre></td></tr></table></figure><h2 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h2><ul><li>Markdown 的粗体和斜体也非常简单，用两个 <em> 包含一段文本就是粗体的语法，用一个 </em> 包含一段文本就是斜体的语法。</li></ul><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ul><li>表格是我觉得 Markdown 比较累人的地方，例子如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| Tables        | Are           | Cool  |</span><br><span class="line">| ------------- |:-------------:| -----:|</span><br><span class="line">| col 3 is      | right-aligned | $1600 |</span><br><span class="line">| col 2 is      | centered      |   $12 |</span><br><span class="line">| zebra stripes | are neat      |    $1 |</span><br></pre></td></tr></table></figure><p>这种语法生成的表格如下：<br>| Tables        | Are           | Cool  |<br>| ————- |:————-:| —–:|<br>| col 3 is      | right-aligned | $1600 |<br>| col 2 is      | centered      |   $12 |<br>| zebra stripes | are neat      |    $1 |</p><h2 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h2><p>如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown下实现也非常简单，只需要用两个 ` 把中间的代码包裹起来。图例：</p><p>使用 tab 键即可缩进。</p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>分割线的语法只需要三个 * 号，例如：</p><p>到这里，Markdown 的基本语法在日常的使用中基本就没什么大问题了，只要多加练习，配合好用的工具，写起东西来肯定会行云流水。更多的语法规则，其实 Mou 的 Help 文档栗子很好，当你第一次使用 Mou 时，就会显示该文档。可以用来对用的查找和学习。</p><h2 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐:"></a>相关推荐:</h2><p>工具</p><p>图床工具用来上传图片获取 URL 地址</p><p>Droplr<br>Cloudapp<br>ezShare for Mac<br>围脖图床修复计划<br>在线好用的Markdown工具，为印象笔记而生</p><p>马克飞象，专为印象笔记打造的Markdown编辑器，非常推荐<br>相关文章阅读：</p><p>为什么作家应该用 Markdown 保存自己的文稿</p>]]></content>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>把markdown文件转换为html文件</title>
      <link href="/2016/01/13/markdown2html/"/>
      <url>/2016/01/13/markdown2html/</url>
      <content type="html"><![CDATA[<h1 id="MarkDown自动转换html页面"><a href="#MarkDown自动转换html页面" class="headerlink" title="MarkDown自动转换html页面"></a>MarkDown自动转换html页面</h1><ul><li>因为markdown语法的方便，平常我经常用markdown来做一些笔记，但有时候需要把md文件转换成html页面，所以现在就把转换方法简单记录下，方便大家学习。不过肯定有别的更好的方法，如果你看到了，觉得你有更好的方法，希望你能不吝赐教，交流学习！</li></ul><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><ul><li>首先第一步肯定是安装转换工具了，我现在用的是i5ting_toc这个工具，这个工具是依赖node的，所以需要先安装node的，node的详细安装方法，这里就不细说了，如果不会的，可以去问问老李（百度），</li><li><p>然后在npm中执行以下命令，npm会自动安装，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g i5ting_toc</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h2 id="文件转换"><a href="#文件转换" class="headerlink" title="文件转换"></a>文件转换</h2><ul><li><p>安装完成之后，就开始准备转换了，那么我们在你要转换的markdown文件的文件夹，按住shift键右键点击文件夹空白地方，会弹出右键菜单，然后选择“打开命令行窗口”选项，接着在命令行输入以下命令，系统就会自动输出html文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i5ting_toc -f note.md -o</span><br><span class="line">//note.md 为需要转换的文件名</span><br><span class="line">//-o 在转换完成之后会自动打开html页面</span><br></pre></td></tr></table></figure></li></ul><ul><li>完毕，至此，我们的文件已经转换完成了，至于更换模板什么的，我现在还不知道怎么弄，望知道的大神指点一二。不胜感激！</li></ul>]]></content>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> 转换，html </tag>
            
            <tag> i5ting_toc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP简单入门</title>
      <link href="/2015/08/14/PHP%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/"/>
      <url>/2015/08/14/PHP%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h2 id="php基础"><a href="#php基础" class="headerlink" title="php基础"></a>php基础</h2><ul><li><p>定义变量</p><ul><li>变量使用$开头，不能以数字开头，</li><li>大小写敏感(区分大小写)</li></ul></li><li><p>php代码必须写在<code>&lt;?php 代码  ?&gt;</code>,</p></li><li><p>在第一行加上下面这行代码可以防止中文乱码问题</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header(<span class="string">"Content-Type:text/html;charset=utf-8"</span>);</span><br></pre></td></tr></table></figure></li><li><p>php变量的类型：    字符串，整型，浮点型，布尔类型，数组</p></li></ul><a id="more"></a><ul><li>函数    <ul><li>与js基本一致</li><li>函数的形参可以设置一个默认值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo($username = &quot;zs&quot;) &#123;</span><br><span class="line">echo &quot;你好&quot;.$username;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></li></ul></li></ul><!-- more --><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>php里面有两种类型的数组，普通数组和关联数组</li></ul><ol><li><p>普通数组</p><ul><li><p>定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$arr1 = array(&quot;zs&quot;,&quot;ls&quot;);</span><br></pre></td></tr></table></figure></li><li><p>数组没有length属性，</p></li><li>遍历数组,使用for循环，可以得到数组的长度</li><li>php有一个函数可以获取数组的长度，count($arr);</li></ul></li><li><p>关联数组</p><ul><li>以键值对的方式进行存储的数组，我们叫做关联数组，<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$array = <span class="keyword">array</span>(<span class="string">"key"</span> =&gt; <span class="string">"value"</span>);</span><br><span class="line">$array[<span class="string">"key];</span></span><br><span class="line"><span class="string">//通过key可以获取值</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>二维数组</p><ul><li>数组里边还有数组</li></ul></li></ol><h2 id="输出打印"><a href="#输出打印" class="headerlink" title="输出打印"></a>输出打印</h2><ul><li>php提供了三个用来输出的方法</li></ul><ol><li><p>echo “”;     用来输出字符串的</p></li><li><p>print_r();    用来输出数组或者对象的。</p></li><li><p>var_dump();    这个也是用来输出数组里面的详细信息</p></li></ol><h2 id="php常见函数方法"><a href="#php常见函数方法" class="headerlink" title="php常见函数方法"></a>php常见函数方法</h2><ol><li><p>count();    得到数组长度</p></li><li><p>in_array();    </p><ul><li>判断数组中是否存在某个元素，这个是用在普通数组当中的</li></ul></li><li><p>array_key_exists();    </p><ul><li>检测数组中是否存在某个key，这个用在关联数组中</li></ul></li><li><p>file_get_contents();    </p><ul><li>读取文件里边的内容，读取出来的是字符串，</li></ul></li><li><p>move_upload_file();    移动上传的文件</p></li></ol><h2 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h2><ul><li><p>name属性 是用来提供给服务端接收数据而设置的</p></li><li><p>action属性 设置接收数据的处理程序</p></li><li><p>method属性    设置发送数据的方式</p></li><li><p>当上传文件时，必须设置 <code>enctype=&quot;multipart/form-data&quot;</code>,且只能使用post方式</p></li><li><p>$_GET    接收get传来的数据</p></li><li><p>$_POST    接收post传来数据</p></li><li><p>$_FILES    接收上传的文件</p></li></ul><h2 id="get和post提交"><a href="#get和post提交" class="headerlink" title="get和post提交"></a>get和post提交</h2><ol><li><p>get</p><ul><li><p>点击超链接，表单提交默认方式就是get，地址栏输入地址，</p></li><li><p>传递到服务端的都是参数，参数值，可以传递多个参数参数值</p></li><li>第一个必须是？ 参数名=参数值</li><li>可以发送多个参数到服务器</li><li>假设我要发送多个数据，</li><li><p>第二个参数之前添加&amp;字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;01.php?username=zs&amp;age=12&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure></li><li><p>在php要对请求进行处理，处理我们分为三个步骤，</p></li></ul><ol><li>接收请求，接收客户端传递到服务端的数据，<ul><li>如果客户端是get方式提交，用$_GET去接收数据，对应的值是一个数组，是一个关联数组。</li></ul></li><li>处理请求：    接收到数据之后具体做什么，就是要使用php去操作了。</li><li>响应处理，给客户端一个响应</li></ol></li><li><p>post提交</p><ul><li><p>表单提交一般都是使用post</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--post 提交，我需要表单提交，设置成post--&gt;</span><br><span class="line">   &lt;form action=&quot;02post.php&quot; method=&quot;post&quot;&gt;</span><br><span class="line">       用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;</span><br><span class="line">       &lt;input type=&quot;submit&quot; value=&quot;post 提交&quot;&gt;</span><br><span class="line">   &lt;/form&gt;</span><br></pre></td></tr></table></figure></li><li><p>服务端处理</p></li></ul><ol><li><p>接收请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$username = $_POST[&quot;username&quot;];</span><br></pre></td></tr></table></figure></li><li><p>处理请求</p></li></ol><ul><li>php后端处理数据</li></ul><ol start="3"><li>完成响应</li></ol><ul><li>返回信息到客户端</li></ul></li></ol><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h4 id="前端页面"><a href="#前端页面" class="headerlink" title="前端页面"></a>前端页面</h4><ul><li>必须满足以下条件才可以上传文件</li></ul><ol><li><p>必须是表单提交</p></li><li><p>表单里面必须有 input type=”file”</p></li><li><p>必须是post方式提交</p></li><li><p>必须设置 <code>enctype=&quot;multipart/form-data&quot;</code>属性</p></li></ol>]]></content>
      
      
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <link href="/404.html"/>
      <url>/404.html</url>
      <content type="html"><![CDATA[layout: false title: "My Blog Name | 404" ---<!DOCTYPE HTML><html><head>    <meta http-equiv="content-type" content="text/html;charset=utf-8;">    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    <meta name="robots" content="all">    <meta name="robots" content="index,follow">    <link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"></head><body>    <script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homepageurl="/" homepagename="回到我的主页">    </script>    <script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"></script>    <script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"></script></body></html>]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/person.html"/>
      <url>/person.html</url>
      <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title></head><body>    <div>        啊是分开时间段放假啦    </div></body></html>]]></content>
    </entry>
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>王攀升</title>
      <link href="/me/index.html"/>
      <url>/me/index.html</url>
      <content type="html"><![CDATA[<!--##    加速建设中。。。。。--><!--<iframe src="../person.html" width="600px" height="800px"></iframe>--><style>    #person {        width: 800px;        height: 500px;        border: 1px solid #ccc;}</style><div id="person"></div>]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>友情链接</title>
      <link href="/%E5%8F%8B%E9%93%BE/index.html"/>
      <url>/%E5%8F%8B%E9%93%BE/index.html</url>
      <content type="html"><![CDATA[<p><a href="http://www.zhangxinxu.com/" target="_blank" rel="noopener">张鑫旭博客：http://www.zhangxinxu.com/</a><br><a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="noopener">阮一峰博客：http://www.ruanyifeng.com/blog/</a><br><a href="http://www.51cto.com/" target="_blank" rel="noopener">51CTO.COM：http://www.51cto.com/</a></p>]]></content>
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
